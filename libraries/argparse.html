<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Understanding Core.Command and Cmdliner - Fairyland OCaml</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../asset/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../SUMMARY.html">Summary</a></li><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="../libraries/hashcons.html">Understanding Hashcons</a></li><li class="chapter-item expanded affix "><a href="../libraries/argparse.html" class="active">Understanding Core.Command and Cmdliner</a></li><li class="chapter-item expanded affix "><a href="../core/container-elements.html">What are [@@deriving compare, sexp_of, hash] for?</a></li><li class="chapter-item expanded affix "><a href="../internals/polymorphic-compare.html">What is polymorphic compare?</a></li><li class="chapter-item expanded affix "><a href="../core/maps-and-hashtables.html">Understanding Data Collections in Core</a></li><li class="chapter-item expanded affix "><div>Using Hashcons</div></li><li class="chapter-item expanded affix "><div>Understanding Fix</div></li><li class="chapter-item expanded affix "><div>Using Fix</div></li><li class="chapter-item expanded affix "><div>Understanding Ocamlgraph</div></li><li class="chapter-item expanded affix "><div>Profiling</div></li><li class="chapter-item expanded affix "><div>Deriving print</div></li><li class="chapter-item expanded affix "><div>Understanding type format6</div></li><li class="chapter-item expanded affix "><div>Understanding module Format</div></li><li class="chapter-item expanded affix "><div>Understanding destructive substitution</div></li><li class="chapter-item expanded affix "><div>Fixed point</div></li><li class="chapter-item expanded affix "><div>Contravariant</div></li><li class="chapter-item expanded affix "><div>Typeclassopedia</div></li><li class="chapter-item expanded affix "><div>OCaml source reading</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fairyland OCaml</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="understanding-corecommand-and-cmdliner"><a class="header" href="#understanding-corecommand-and-cmdliner">Understanding <code>Core.Command</code> and <code>Cmdliner</code></a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Command-line parse libraries e.g. <code>Core.Command</code> and <code>Cmdliner</code> are notoriously difficult to understand and use. The tension may come from people require a quick solution, while both these libraries target to be full-feathered tools with abstractions and concepts. This post aims to provide an understanding guide for them. Their official tutorials are at <a href="https://dev.realworldocaml.org/command-line-parsing.html">RWO/Command-Line Parsing</a> and <a href="https://erratique.ch/software/cmdliner/doc/tutorial.html">cmdliner/tutorial</a>. I hope you can be much clear to jump back to them after reading this guide.</p>
<h2 id="four-concepts"><a class="header" href="#four-concepts">Four Concepts</a></h2>
<p>Both libraires provide four levels of concepts:</p>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>Stage</th><th>Composable</th><th>Core.Command</th><th>Cmdliner</th></tr></thead><tbody>
<tr><td>Argument Parser</td><td>Step 3</td><td>no</td><td><code>'a Arg_type.t</code></td><td><code>'a Arg.conv = 'a parser * 'a printer</code></td></tr>
<tr><td>Argument Handler</td><td>Step 3</td><td>yes</td><td><code>'a Param.t</code></td><td><code>'a Term.t</code></td></tr>
<tr><td>Command Item</td><td>Step 2</td><td>yes</td><td><code>unit Command.t</code></td><td><code>'a Cmd.t</code></td></tr>
<tr><td>Driver</td><td>Step 1</td><td>no</td><td><code>Command.run</code></td><td><code>Cmd.eval</code>,  <code>Cmd.eval_value</code></td></tr>
</tbody></table>
</div><div style="text-align: center"> Table 1 - Concepts for Core.Command and Cmdliner </div>
<p><strong>Argument Parser</strong> provides functions to parse a raw string to the expected type <code>'a</code>. They both provide parsers inside <a href="https://v3.ocaml.org/p/core/latest/doc/Core/Command/Spec/index.html#val-string">Core/Command/Spec</a> and <a href="https://erratique.ch/software/cmdliner/doc/Cmdliner/Arg/index.html#converters">Cmdliner/Predefined_converters</a> for common types. <code>Cmdliner.Arg.conv</code> is a pair of a parser with a printer.</p>
<p><strong>Argument Handler</strong> wraps a parser with extra properties to handle command-line argument e.g. whether it's required or optional, whether it's repeated, with a flag or not, the doc string for it. <strong>Argument Handler</strong> may not need <strong>Parsing</strong> in examples that a flag argument carries no values. The existence or not means a boolean parameter e.g. <code>-v</code> (rather than <code>-log=WARNING</code>).</p>
<p>In both libraries, <strong>Argument Handlers</strong> are not directed used by <strong>Drivers</strong>. <strong>Argument Handlers</strong> are packed into a <strong>Command Item</strong>, and then <strong>drivers</strong> take <strong>Command Item</strong> and perform the real parsing work. A <strong>Command Item</strong> for a whole sub-command e.g. <code>push ...</code> in <code>git push ...</code>. You may have other sub-commands like <code>git clone</code>, <code>git pull</code>, and you need to group these <strong>Command Items</strong> into a compound <strong>Command Item</strong>.</p>
<p>In Table 1, The Column <strong>Stage</strong> lists the time order during a real command-line parsing. </p>
<ul>
<li>Step 1: <strong>Driver</strong> are usually the unique top function of your program. It takes the <code>Sys.argv</code> and invodes your <strong>Command Item</strong>.</li>
<li>Step 2: <strong>Driver</strong> dispatches to the <strong>Command Item</strong>.</li>
<li>Step 3: <strong>Argument Handler</strong> performs the parsing and handling, with the <strong>Argument Parser</strong> in it if having one.</li>
</ul>
<h2 id="driver-functions"><a class="header" href="#driver-functions">Driver functions</a></h2>
<p><code>Core.Command</code> can only build up to a <code>Command.t</code>. It doesn't provide any driver functions. The <strong>driver function</strong> <code>Core.Command.run</code> is defined in another library <code>core_unix.command_unix</code>. It takes the <code>Core.Command.t</code> and start the work.</p>
<p><code>Cmdliner</code> has a variant of <strong>driver functions</strong> e.g. <code>Cmd.eval</code> and <code>Cmd.eval_value</code>. Since they're supposed to be the unique top functions, <code>Cmd.eval</code> returns a <code>unit</code> while <code>Cmd.eval</code> returns a <code>int</code> (standard error code) that is used by <code>exit</code>. </p>
<p>It's a common myth that people seek to get the unboxed parsed result. Such a function is not even provided in <code>Core.Command</code>. It's do-able with <code>Cmdliner.Cmd.eval_value : ... -&gt; ?argv:string array -&gt; 'a Cmd.t -&gt; ('a Cmd.eval_ok, Cmd.eval_error) result</code>. However, you need to tokenize to get <code>argv</code> yourself (Imparient readers can jump to Section <a href="#elimination">Elimination</a>).</p>
<h2 id="diagrams-for-corecommand-and-cmdliner"><a class="header" href="#diagrams-for-corecommand-and-cmdliner">Diagrams for <code>Core.Command</code> and <code>Cmdliner</code></a></h2>
<p>Both <code>Core.Command</code> and <code>Cmdliner</code> have two-layered compositional datatypes. An element in the inner layer is to parse one key-value pair (or key-only or value-only). For example, we're going to parse <code>-v -a=1 -b=t 42</code>.</p>
<p>The inner layer for <code>Core.Command</code> is a compositional <code>Param.t</code>. We will have four <code>Param.t</code> that are</p>
<ul>
<li><code>bool Param.t</code> for <code>-v</code></li>
<li><code>int Param.t</code> for <code>-a=1</code> in which a <code>int Arg_type</code> to parse <code>1</code></li>
<li><code>string Param.t</code> for <code>-b=t</code> in which a <code>string Arg_type</code> to parse <code>t</code></li>
<li><code>int Param.t</code> for <code>42</code> in which a <code>int Arg_type</code> to parse <code>42</code></li>
</ul>
<p>The inner layer for <code>Cmdliner</code> is a compositional <code>Term.t</code>. We will have four <code>Term.t</code> that are</p>
<ul>
<li><code>bool Term.t</code> for <code>-v</code></li>
<li><code>int Term.t</code> for <code>-a=1</code> in which a <code>int Arg.conv</code> to parse <code>1</code></li>
<li><code>string Term.t</code> for <code>-b=t</code> in which a <code>string Arg.conv</code> to parse <code>t</code></li>
<li><code>int Term.t</code> for <code>42</code> in which a <code>int Arg.conv</code> to parse <code>42</code></li>
</ul>
<p>The inner layer data are wrapped into outer layer data <code>Core.Command.t</code> or <code>Cmdliner.Cmd.t</code> via packing function <code>Core.Command.basic</code> or <code>Cmdliner.Cmd.v</code>. A outer layer data is usually used for argparsing one command-line case. It is also composable and is used to group sub-commands. <a href="https://v3.ocaml.org/p/core/latest/doc/Core/Command/index.html#val-group"><code>Core.Command.group</code></a> takes <code>(string * Core.Command.t) list</code> and returns a <code>Core.Command.t</code>. <a href="https://erratique.ch/software/cmdliner/doc/Cmdliner/Cmd/index.html#val-group"><code>Cmdlinder.Cmd.group</code></a> takes <code>Cmdliner.Cmd.t list</code> and returns a <code>Cmdliner.Cmd.t</code>.</p>
<p>Their diagrams are very alike in the respective of our <strong>four concepts</strong>. A rectangle corresponds to a type. An edge is a function that transforms datatype. A rounded rectangle is also a function but at an endpoint (It's rare. Only two driver functions and one <code>Arg.flag</code>). Four compositional datatypes <code>Param.t</code> <code>Command.t</code> <code>Term.t</code> <code>Cmd.t</code> should be in stacked rectangles (but here I just use a rectangle with double edges). I omit the doc-related components to make it clear. </p>
<pre class="mermaid">---
title: Figure 1.1 - Diagram for Core.Command
---
graph LR
  subgraph at [Argument Parser]
    AT[Arg_type.t]
  end

  subgraph sp [Argument Handler]
    subgraph fa [Flag &amp; Anons]
      CA1[Anons.t]
      CF1[Flag.t]
      CF2[no_arg : Flag.t]
    end

    AT --&gt; |&quot;Anons.(%:)&quot;| CA1
    AT --&gt; |Param.required| CF1

    P0[[Param.t]] --&gt; |&quot;Param.map&quot;| P0

    CA1--&gt; |Param.anon| P0
    CF1 --&gt; |Param.flag| P0
    CF2 --&gt; |Param.flag| P0
  end
  
  subgraph sg [Command Item]
    C0[[Command.t]] --&gt; | Command.group | C0
  end

  P0 --&gt; |Command.basic| C0

  subgraph sd [Driver]
    direction LR
    Cr(Command.run)
    C0 -.-&gt; Cr
  end
</pre>
<pre class="mermaid">---
title: Figure 1.2 - Diagram for Cmdliner
---
graph LR
  subgraph ap [Argument Parser]
    AC[Arg.conv]
  end

  AC --&gt; |Arg.pos| AT1
  AC --&gt; |Arg.opt| AT2

  subgraph sa [Argument Handler]
    subgraph at [Arg.t]
      AT1[Arg.t]
      AT2[Arg.t]
      AT3(Arg.flag ~&gt; Arg.t)
    end

    AT1 --&gt; |Arg.value| P0
    AT2 --&gt; |Arg.value| P0
    AT3 --&gt; |Arg.value| P0

    P0[[Term.t]] --&gt; |&quot;Term.($)&quot;| P0
  end

  P0 --&gt; |Cmd.v| C0

  subgraph sg [Command Item]
    direction LR
    C0[[Cmd.v]] --&gt; |Cmd.group| C0
  end

  subgraph sd [Driver]
    direction LR
    Cr(Cmd.eval)
    Cv(Cmd.eval_value)
    C0 .-&gt; Cr
    C0 .-&gt; Cv
  end
</pre>
<h2 id="how-paramt-and-termt-are-made"><a class="header" href="#how-paramt-and-termt-are-made">How <code>Param.t</code> and <code>Term.t</code> are made</a></h2>
<p>A <code>Core.Command.t</code> consists of the <em>flagged</em> parameters and <em>anonymous</em> (flag-less) parameters. A <code>Cmdlinder.t</code> is consists of <em>optional arguments</em> and <em>positional arguments</em>. They are <strong>Argument Handlers</strong>. Note <strong>Argument Handlers</strong> use <strong>Argument Parsers</strong>.</p>
<p>In <code>Core.Command</code>, A primitive <code>'a Param.t</code> can made up from ingridients</p>
<ol>
<li><code>'a Arg_type.t</code> parses <code>string</code> to <code>'a</code></li>
<li><code>'a Flag.t</code> can wrap <code>'a Arg_type.t</code> as <code>required</code>, <code>optional</code>, or <code>optional_with_default</code></li>
<li><code>'bool Flag.t</code> requires no <code>'a Arg_type.t</code>. Therefore its existence denotes a <code>true</code> or <code>false</code></li>
<li><code>'a Anons.t</code> which wraps <code>'a Arg_type.t</code></li>
<li><code>Param.flag</code> makes <code>'a Flag.t</code> a <code>'a Param.t</code></li>
<li><code>Param.anon</code> makes <code>'a Anons.t</code> a <code>'a Param.t</code></li>
</ol>
<p>In <code>Cmdlinder</code>, the ingridients to make up a primitive <code>'a Term.t</code> are:</p>
<ol>
<li><code>'a Arg.conv</code> defines both a parser and a printer for <code>'a</code></li>
<li><code>Arg.opt</code> wraps <code>'a Arg.conv</code> an optional flagged argument <code>'a Arg.t</code>.</li>
<li><code>Arg.pos</code> wraps <code>'a Arg.conv</code> and makes a positional argument at certain index <code>'a Arg.t</code></li>
<li><code>Arg.flag</code> makes a pure flag optional argument <code>bool Arg.t</code></li>
<li><code>Arg.value</code> makes <code>'a Arg.t</code> a <code>'a Term.t</code></li>
</ol>
<p>The listing and the diagram are not complete, but they are sufficient to illuminate.</p>
<h2 id="pack-argument-handler-to-command-item"><a class="header" href="#pack-argument-handler-to-command-item">Pack <strong>Argument Handler</strong> to <strong>Command Item</strong></a></h2>
<p><strong>Driver</strong> functions takes a <strong>Command Item</strong> packed from a <strong>Argument Handler</strong>. <code>Param.t</code> and <code>Term.t</code> can compose just like parser combinator or prettyprinter. They should be <code>Applicative</code> (or also <code>Contravariant</code> ?)</p>
<h3 id="pack-commandparamt-to-commandt"><a class="header" href="#pack-commandparamt-to-commandt">Pack <code>Command.Param.t</code> to <code>Command.t</code></a></h3>
<p>The pack function for <code>Command</code> is <code>Command.basic</code>.</p>
<pre><code class="language-ocaml"># #require &quot;core&quot;;;
# open Core;;
# Command.Param.map;;
- : 'a Command.Spec.param -&gt; f:('a -&gt; 'b) -&gt; 'b Command.Spec.param = &lt;fun&gt;

# #show Command.basic;;
val basic : unit Command.basic_command

# #show Command.basic_command;;
type nonrec 'result basic_command =
    summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt;
    (unit -&gt; 'result) Command.Spec.param -&gt; Command.t
</code></pre>
<p>Type <code>Command.Spec.param</code> is an alias for <code>Command.Param.t</code>. We can see the types for first argument and the return type of <code>Command.Param.map</code>, and the second-to-last argument of <code>Command.basic_command</code>, are all <code>Command.Param.t</code>. <code>'result</code> is set to be <code>unit</code> in <code>Command.basic</code>.</p>
<p>The task left for users is to provide a function that maps parsed result <code>'a Param.t</code> to <code>(unit -&gt; unit) Param.t</code>.</p>
<p>The following two lines are equal. It's a partially applied <code>Param.map</code> from <code>string Param.t</code> to an unknown <code>~f : string -&gt; '_weak</code>:</p>
<pre><code class="language-ocaml"># Command.Param.(%:);;
- : string -&gt; 'a Command/2.Arg_type.t -&gt; 'a Command.Spec.anons = &lt;fun&gt;

# Command.Param.string;;
- : string Command/2.Arg_type.t = &lt;abstr&gt;

# Command.Param.(map (anon (&quot;filename&quot; %: string)));;
- : f:(string -&gt; '_weak1) -&gt; '_weak1 Command.Spec.param = &lt;fun&gt;

# Command.(let s : string Param.Arg_type.t = Param.string in let a = Param.(%:) &quot;filename&quot; s in Param.map (Param.anon a));;
- : f:(string -&gt; '_weak2) -&gt; '_weak2 Command.Spec.param = &lt;fun&gt;
</code></pre>
<p>In the following example of <code>Command.basic</code>, our function <code>(fun file () -&gt; ignore file)</code> satisfied the type requirement. The observation here is <code>Command.basic</code> requires an argument of type <code>(unit -&gt; unit) Command.Spec.param</code>. The user <em>comsume-all-parsed</em> code is usually like <code>Param.map a_b_c_param ~f:(fun a b c () -&gt; ...; () ) : (unit -&gt; unit) Command.Spec.param</code>. The parsed result is passed before the last argument <code>()</code>.</p>
<pre><code class="language-ocaml"># Command.basic ~summary:&quot;fairy file&quot; Command.Param.(map (anon (&quot;filename&quot; %: string)) ~f:(fun file () -&gt; ignore file));;
- : Command.t = &lt;abstr&gt;
</code></pre>
<p>To make it familiar to RWO readers, we use <code>let%map_open</code> instead of <code>Param.map</code>. The code is equivalent to the above one:</p>
<pre><code class="language-ocaml"># #require &quot;ppx_jane&quot;;;

# let%map_open.Command file = (anon (&quot;filename&quot; %: string)) in file;;
- : string Command.Spec.param = &lt;abstr&gt;

# Command.basic ~summary:&quot;fairy file&quot; (let%map_open.Command file = (anon (&quot;filename&quot; %: string)) in fun () -&gt; ignore file);;
- : Command.t = &lt;abstr&gt;
</code></pre>
<h3 id="pack-cmdlinertermt-to-cmdlinercmdt"><a class="header" href="#pack-cmdlinertermt-to-cmdlinercmdt">Pack <code>Cmdliner.Term.t</code> to <code>Cmdliner.Cmd.t</code></a></h3>
<p><code>Cmdliner</code> uses <em>pure</em> (<code>Term.const : 'a -&gt; 'a t</code>) and <em>ap</em> (<code>Term.($) : ('a -&gt; 'b) t -&gt; 'a t -&gt; 'b t</code>) to compose <code>Term.t</code>. Unlike <code>Command.basic</code>, the user <em>comsume-all-parsed</em> code is usually like <code>Term.(const (fun a b c -&gt; ...; () )) $ a_param $ b_param $ c_param : unit Term.t</code>. <code>Term.v</code> packs this value to get a <code>Cmd.t</code>, then this <code>Cmd.t</code> can be used in the driver function <code>Cmd.eval</code>.</p>
<pre><code class="language-ocaml"># #require &quot;cmdliner&quot;;;
# open Cmdliner;;

# Arg.(&amp;);;
- : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;

# Arg.value;;
- : 'a Cmdliner.Arg.t -&gt; 'a Term.t = &lt;fun&gt;

# Arg.string;;
- : string Arg.converter = (&lt;fun&gt;, &lt;fun&gt;)

# let file = Arg.(value &amp; pos 0 string &quot;default_name&quot; (Arg.info []));;
val file : string Term.t = &lt;abstr&gt;

# Cmd.v (Cmd.info &quot;fairy file&quot;) Term.((const (fun filename -&gt; ignore filename)) $ file );;
- : unit Cmd.t = &lt;abstr&gt;
</code></pre>
<p>The difference between their approaches is <code>Command</code> puts the <em>comsume-all-parsed</em> function at last while <code>Cmdliner</code> puts it at first. They both use functional jargons e.g. <code>let%map_open</code>, <code>Anon.(%:)</code>, <code>Arg.(&amp;)</code> and <code>Term.($)</code>. They help to compact the code, at the cost of confusing newcomers.</p>
<h2 id="syntax-for-command-line-languages"><a class="header" href="#syntax-for-command-line-languages">Syntax for Command-line Languages</a></h2>
<p>It's not explicitly specified, but their design and APIs suggest (or <em>check</em>) possible syntax for the command-line languages. e.g. for the flag-less parts, <code>Command</code> treats them as anonymous arguments and allow the a sequence of them. The run-time validity of <code>Param.t</code> is less powerful than its static type. In this example, Anonymous <code>int</code> after a list of anonymous <code>string</code> causes an exception for its syntax.</p>
<pre><code class="language-ocaml"># let my_param = 
    (let%map_open.Command str_lst = anon (sequence (&quot;str&quot; %: string)) 
    and extra_int = anon (&quot;int&quot; %: int) in 
    fun () -&gt; ());;
val my_param : (unit -&gt; unit) Command.Spec.param = &lt;abstr&gt;

# Command.basic ~summary:&quot;my_param&quot; my_param ;;
Exception:
Failure
 &quot;the grammar [STR ...] INT for anonymous arguments is not supported because there is the possibility for arguments (INT) following a variable number of arguments ([STR ...]).  Supporting such grammars would complicate the implementation significantly.&quot;.
Raised at Stdlib.failwith in file &quot;stdlib.ml&quot;, line 29, characters 17-33
Called from Base__List0.fold in file &quot;src/list0.ml&quot;, line 37, characters 27-37
Called from Command.Anons.Grammar.concat in file &quot;command/src/command.ml&quot;, line 1000, characters 10-729
Called from Command.basic in file &quot;command/src/command.ml&quot;, line 2373, characters 14-22
Called from Topeval.load_lambda in file &quot;toplevel/byte/topeval.ml&quot;, line 89, characters 4-14
</code></pre>
<p><code>Cmdliner</code> treats flag-less parts as positional arguments. The manual warns it's the user's <em>duty</em> to ensure the unique use of a position. <code>Arg</code> provides functions to either preciously points to one position index, or to range all, or to cover the left/right to a given position index. Duplication of position index will trigger run-time exception.</p>
<pre><code class="language-ocaml"># let top_t =
  let ai = Arg.info [] in
  let str_lst : string list Term.t = Arg.(value &amp; pos_all string [] ai) in
  let extra_int : int Term.t = Arg.(value &amp; pos 1 int 0 ai) in
  let handle_all : (string list -&gt; int -&gt; unit) Term.t =
    Term.const @@ fun _str_list _extra_int -&gt; ()
  in
  Term.(handle_all $ str_lst $ extra_int);;
val top_t : unit Term.t = &lt;abstr&gt;

# let c =
  let i = Cmd.info &quot;&quot; in
  Cmd.v i top_t ;;
val c : unit Cmd.t = &lt;abstr&gt;

# Cmd.eval_value ~argv:[| &quot;a&quot;; &quot;2&quot; |] c;;
- : (unit Cmd.eval_ok, Cmd.eval_error) result = Stdlib.Ok (`Ok ())

# Cmd.eval_value ~argv:[| &quot;a&quot;; &quot;b&quot; |] c;;
: invalid value 'b', expected an integer
Usage:  [OPTION]… [ARG]…
Try ' --help' for more information.
- : (unit Cmd.eval_ok, Cmd.eval_error) result = Stdlib.Error `Parse
</code></pre>
<h2 id="summary-and-questions"><a class="header" href="#summary-and-questions">Summary and Questions</a></h2>
<p>To recap, after skipping documenting, escaping, error code, auto-completing, two of the most popular command-line libraries <code>Core.Command</code> and <code>Cmdliner</code> can be grasped via four concepts i.e. <strong>Argument Parser</strong>, <strong>Argument Handler</strong>, <strong>Command Item</strong>, and <strong>Driver</strong>. The <a href="#diagrams-for-corecommand-and-cmdliner">diagram</a> not only shows their internal relation, but also reveal the similarity between them. I don't have time to re-comment all their documents and tutorials from my viewpoint, but you're well equipped to go back for them ((for <a href="https://dev.realworldocaml.org/command-line-parsing.html"><code>Command</code></a> and for <a href="https://erratique.ch/software/cmdliner/doc/tutorial.html"><code>Cmdliner</code></a>)) after this post.</p>
<p>Explicit syntax for for command-line languages and static safety typed parsing arise very interesting problems to me. I will delve into it in future posts.</p>
<h2 id="elimination"><a class="header" href="#elimination">Elimination</a></h2>
<p>For command-line parsing, OCaml has build-in <code>Sys.argv</code> and standard library <code>Arg</code> module (<a href="https://ocaml.org/docs/cli-arguments">tutorial</a>).</p>
<p>⚠️ We can let <code>Core.Command</code> return the parsed result with a mutable reference, even its pack function and driver function requires a <code>unit</code> return value. When a functional program is <a href="https://dl.acm.org/doi/pdf/10.1145/317636.317775">not</a> a functional program?</p>
<pre><code class="language-ocaml"># let store = ref &quot;&quot; in 
  Command.basic ~summary:&quot;fairy file&quot; Command.Param.(map (anon (&quot;filename&quot; %: string)) ~f:(fun file () -&gt; store := file; ()));;
- : Command.t = &lt;abstr&gt;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../libraries/hashcons.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../core/container-elements.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../libraries/hashcons.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../core/container-elements.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" charset="utf-8"></script>
        <script src="../mark.min.js" charset="utf-8"></script>
        <script src="../searcher.js" charset="utf-8"></script>

        <script src="../clipboard.min.js" charset="utf-8"></script>
        <script src="../highlight.js" charset="utf-8"></script>
        <script src="../book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="../asset/mermaid.min.js"></script>
        <script src="../asset/mermaid-init.js"></script>


    </body>
</html>
