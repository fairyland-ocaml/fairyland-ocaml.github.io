<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using Z3.Datatype - Fairyland OCaml</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../asset/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../SUMMARY.html">Summary</a></li><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="../libraries/hashcons.html">Understanding Hashcons</a></li><li class="chapter-item expanded affix "><a href="../libraries/argparse.html">Understanding Core.Command and Cmdliner</a></li><li class="chapter-item expanded affix "><a href="../libraries/z3-datatype.html" class="active">Using Z3.Datatype</a></li><li class="chapter-item expanded affix "><a href="../core/container-elements.html">What are [@@deriving compare, sexp_of, hash] for?</a></li><li class="chapter-item expanded affix "><a href="../internals/polymorphic-compare.html">What is polymorphic compare?</a></li><li class="chapter-item expanded affix "><a href="../core/maps-and-hashtables.html">Understanding Data Collections in Core</a></li><li class="chapter-item expanded affix "><div>Using Hashcons</div></li><li class="chapter-item expanded affix "><div>Understanding Fix</div></li><li class="chapter-item expanded affix "><div>Using Fix</div></li><li class="chapter-item expanded affix "><div>Understanding Ocamlgraph</div></li><li class="chapter-item expanded affix "><div>Profiling</div></li><li class="chapter-item expanded affix "><div>Deriving print</div></li><li class="chapter-item expanded affix "><div>Understanding type format6</div></li><li class="chapter-item expanded affix "><div>Understanding module Format</div></li><li class="chapter-item expanded affix "><div>Understanding destructive substitution</div></li><li class="chapter-item expanded affix "><div>Fixed point</div></li><li class="chapter-item expanded affix "><div>Contravariant</div></li><li class="chapter-item expanded affix "><div>Typeclassopedia</div></li><li class="chapter-item expanded affix "><div>OCaml source reading</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fairyland OCaml</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="using-z3datatype"><a class="header" href="#using-z3datatype">Using <code>Z3.Datatype</code></a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This post is for explaining some concepts and show usage for library <a href="https://opam.ocaml.org/packages/z3/"><code>ocaml-z3</code></a> and my library <a href="https://github.com/arbipher/ocaml_fairy_z3"><code>fairy_z3</code></a>. My long-time goal is to make <em>Solve Anything</em> easy in OCaml, and this is just a first step.</p>
<p>Roughly, z3 has coresponding data structures for <em>expressions</em>, <em>primitive types</em> and <em>datatypes</em>, as like these in OCaml. I will not discuss the details of <em>logic</em> or <em>theory</em> used in a SMT solver Z3. We can just treat it as versatile library.</p>
<p>To clarify,</p>
<ul>
<li><em>primitive types</em> in OCaml, e.g. <code>int</code>, <code>boolean</code>, <code>float</code>, <code>string</code>.</li>
<li><em>datatypes</em> in OCaml, variants or records, <code>type t1 = Foo of int * string | Bar of int</code>, <code>type t2 = {a : int; b : float}</code>.</li>
</ul>
<p>In the current ocaml-z3 implementation, there is just one syntactic type <code>Z3.Expr.expr</code> for all z3 expressions and one syntactic type <code>Z3.Sort.sort</code> for the their types. To make this post more clear, we assume there is a better type definition that carries the correct sort of the expression. e.g. <code>Z3Int 42 : Z3_int_exp</code>. (It could be my second step for the long-time goal). Again,</p>
<ul>
<li><em>primitive types</em> in z3, e.g. <code>Z3_int</code>, <code>Z3_boolean</code>.</li>
<li><em>datatypes</em> in Z3 e.g. <code>Z3_t1</code>, <code>Z3_t2</code>.</li>
</ul>
<p>Both OCaml and z3 provide the ways to construct and operate on primitive types. In OCaml, a datatype is easy to define. However, it takes some effect to construct a datatype with ocaml-z3 and use it. That's what this post and <code>fairy_z3</code> targets.</p>
<h2 id="box-unbox-inject-project"><a class="header" href="#box-unbox-inject-project">Box, Unbox, Inject, Project</a></h2>
<p><img src="z3-buip.png" alt="Z3-buip" /></p>
<p>(Mermaid cannot handle nicely diagram in this isometric layout so I have to use excalidraw..)</p>
<p>We have four arrow groups:</p>
<ol>
<li>
<p>(Solid green lines) In the OCaml land, <code>inj</code>(inject) and <code>prj</code>(project) are supported by the language. Given the type <code>t1</code> above, <code>inj</code> is to construct from primitive values to a value in type <code>t1</code> and the <code>prj</code> is to pattern match a value in type <code>t1</code>.</p>
</li>
<li>
<p>(Solid red/blue lines) Between the primitive types of OCaml land and Z3 land. We choose the terms <code>box</code> and <code>unbox</code> to describe a value is to/from another representation in the perspective of OCaml. These functions are on-the-shelf.</p>
</li>
</ol>
<pre><code class="language-ocaml">let box_int : int -&gt; Z3.Expr.expr = 
  fun i -&gt;
    Z3.Arithmetic.Integer.mk_numeral_i ctx i

let unbox_int : Z3.Expr.expr -&gt; int =
  fun e -&gt; 
    e |&gt; Z3.Arithmetic.Integer.get_big_int
      |&gt; Big_int_Z.int_of_big_int
</code></pre>
<pre><code class="language-mdx-error">Line 1, characters 22-34:
Error: Unbound module Z3
</code></pre>
<ol start="3">
<li>
<p>(Another solid green lines) In the Z3 land, <code>inj</code> and <code>prj</code> are achievable but tedious to write. We will demonstrate it in the later section and then advocate using <code>fairy_z3.ppx</code> to derive them instead.</p>
</li>
<li>
<p>(Dotten red/blue lines) Between the datatypes of OCaml land and Z3 land. The <code>box</code> and <code>unbox</code> for datatypes are made of the above three groups.</p>
</li>
</ol>
<h2 id="making-z3-datatype-by-hand"><a class="header" href="#making-z3-datatype-by-hand">Making Z3 Datatype by hand</a></h2>
<p>Z3 has <a href="https://microsoft.github.io/z3guide/docs/theories/Datatypes/">tutorial</a> and <a href="https://z3prover.github.io/api/html/ml/Z3.Datatype.html">api manual</a>. Now I cannot remember how I figured out how to use it. Some z3 issues definitely helped.</p>
<p>If you have a glance of its api, you can find <code>constructor</code>, <code>recognizer</code>, <code>accessor</code> as well as <code>sort</code> and <code>func_decl</code>. Conceptually, <code>func_decl</code> are <em>functions</em> in <strong>Z3 land</strong> and <code>sort</code> are <em>types</em> in <strong>Z3 land</strong>. <code>constructor</code>, <code>recognizer</code> and <code>accessor</code> are certain <em>functions</em> and their functionalities are like the OCaml <em>functions</em> around OCaml <em>datatypes</em> but in <strong>Z3 land</strong>.</p>
<p>We first prepare the helper Z3 definitions in the group 2.</p>
<pre><code class="language-ocaml"># #require "z3";;

# open Z3;;

# let ctx = mk_context [];;
val ctx : context = &lt;abstr&gt;
# let int_sort = Arithmetic.Integer.mk_sort ctx;;
val int_sort : Sort.sort = &lt;abstr&gt;
# let int_sort = Arithmetic.Integer.mk_sort ctx;;
val int_sort : Sort.sort = &lt;abstr&gt;
# let string_sort = Seq.mk_string_sort ctx;;
val string_sort : Sort.sort = &lt;abstr&gt;

# let box_int : int -&gt; Z3.Expr.expr = 
  fun i -&gt;
    Z3.Arithmetic.Integer.mk_numeral_i ctx i
val box_int : int -&gt; Expr.expr = &lt;fun&gt;

# let unbox_int : Z3.Expr.expr -&gt; int =
  fun e -&gt; 
    e |&gt; Z3.Arithmetic.Integer.get_big_int
      |&gt; Big_int_Z.int_of_big_int
val unbox_int : Expr.expr -&gt; int = &lt;fun&gt;

# let box_string s = Seq.mk_string ctx s;;
val box_string : string -&gt; Expr.expr = &lt;fun&gt;
# let unbox_string e = Seq.get_string ctx e;;
val unbox_string : Expr.expr -&gt; string = &lt;fun&gt;
</code></pre>
<p>Then we define the example type <code>t1</code>. We also write a few functions <code>ctor_*_ml</code>(constructor), <code>rzer_*_ml</code>(recognizer), <code>asor_*_ml</code>(accessor) in <strong>OCaml land</strong> just for illustrating.</p>
<pre><code class="language-ocaml"># type t1 = Foo of int * string | Bar of int;;
type t1 = Foo of int * string | Bar of int

# let ctor_foo_ml (i,s) = Foo (i,s);;
val ctor_foo_ml : int * string -&gt; t1 = &lt;fun&gt;
# let rzer_foo_ml = function | Foo (_, _) -&gt; true | _ -&gt; false;;
val rzer_foo_ml : t1 -&gt; bool = &lt;fun&gt;
# let asor_foo_0_ml = function | Foo (i, _) -&gt; i | _ -&gt; failwith "only foo";;
val asor_foo_0_ml : t1 -&gt; int = &lt;fun&gt;
</code></pre>
<p>Now we are in <strong>Z3 land</strong>. We can make the constructors and the <em>sort</em>.</p>
<pre><code class="language-ocaml"># Datatype.mk_constructor_s;;
- : context -&gt;
    string -&gt;
    Symbol.symbol -&gt;
    Symbol.symbol list -&gt;
    Sort.sort option list -&gt; int list -&gt; Datatype.Constructor.constructor
= &lt;fun&gt;

# let ctor_foo = Datatype.mk_constructor_s ctx "Foo" 
  (Symbol.mk_string ctx "is-Foo")
  [ Symbol.mk_string ctx "Foo-0"; Symbol.mk_string ctx "Foo-1" ]
  [ Some int_sort; Some string_sort ]
  [ 1; 1 ];;
val ctor_foo : Datatype.Constructor.constructor = &lt;abstr&gt;

# let ctor_bar = Datatype.mk_constructor_s ctx "Bar"
  (Symbol.mk_string ctx "is-Bar")
  [ Symbol.mk_string ctx "Bar-0" ]
  [ Some int_sort ] [ 1 ];;
val ctor_bar : Datatype.Constructor.constructor = &lt;abstr&gt;

# let t1_sort = Datatype.mk_sort_s ctx "t1_sort" [ ctor_foo; ctor_bar ];;
val t1_sort : Sort.sort = &lt;abstr&gt;
</code></pre>
<p>We make a constructor for each variant tag e.g. <code>ctor_foo</code> and in each tag we specify each payload type e.g. <code>int</code> (in `Foo of int * string) its name, sort, and whether it's recursive (non-zero means non-recursive).</p>
<p>A constructor is a variant tag description that used to make a sort. To apply a constructore, we need to first get the associated function a.k.a. <code>func_decl</code> in Z3 land. Then we <em>apply</em> this function in Z3 land via <code>FuncDecl.apply</code>.</p>
<pre><code class="language-ocaml"># let ctor_f_foo = Datatype.Constructor.get_constructor_decl ctor_foo;;
val ctor_f_foo : FuncDecl.func_decl = &lt;abstr&gt;
# let ctor_f_bar = Datatype.Constructor.get_constructor_decl ctor_bar;;
val ctor_f_bar : FuncDecl.func_decl = &lt;abstr&gt;

# let e1_ = Foo (42, "camel");;
val e1_ : t1 = Foo (42, "camel")

# let e1 = ctor_foo_ml (42, "camel");;
val e1 : t1 = Foo (42, "camel")

# let e1_z3 = FuncDecl.apply ctor_f_foo [box_int 42; box_string "camel"];;
val e1_z3 : Expr.expr = &lt;abstr&gt;

# Expr.to_string e1_z3;;
- : string = "(Foo 42 \"camel\")"
</code></pre>
<p>Now we have already make a Z3 expression of <code>t1_sort</code>. We can also make constraint and solve on it. e.g. we can ask to solve <code>(Foo x "camel") == (Foo 42 "camel")</code> then <code>x</code> is <code>42</code>.</p>
<pre><code class="language-ocaml"># let solver = Solver.mk_solver ctx None;;
val solver : Solver.solver = &lt;abstr&gt;

# let e2_z3 = FuncDecl.apply ctor_f_foo [Arithmetic.Integer.mk_const_s ctx "x"; box_string "camel"];;
val e2_z3 : Expr.expr = &lt;abstr&gt;

# let solver_result = Solver.check solver [Boolean.mk_eq ctx e1_z3 e2_z3];;
val solver_result : Solver.status = Z3.Solver.SATISFIABLE

# match solver_result with Solver.SATISFIABLE -&gt; 
  (match Solver.get_model solver with 
    | Some model -&gt; Model.to_string model
    | None -&gt; "no model")
  | _ -&gt; "not sat";;
- : string = "(define-fun x () Int\n  42)"
</code></pre>
<p>Now we have all the ingredients to write <code>inj</code> functions in Z3 land and the <code>box</code> from OCaml to Z3.</p>
<pre><code class="language-ocaml"># let inj_foo (ei,es) = FuncDecl.apply ctor_f_foo [ei; es];;
val inj_foo : Expr.expr * Expr.expr -&gt; Expr.expr = &lt;fun&gt;
# let inj_bar ei = FuncDecl.apply ctor_f_bar [ei];;
val inj_bar : Expr.expr -&gt; Expr.expr = &lt;fun&gt;
# let box_t1 = function 
  | Foo (i,s) -&gt; inj_foo (box_int i, box_string s) 
  | Bar i -&gt; inj_bar (box_int i);;
val box_t1 : t1 -&gt; Expr.expr = &lt;fun&gt;

# box_t1 (Foo (101, "dog")) |&gt; Expr.to_string;;
- : string = "(Foo 101 \"dog\")"
</code></pre>
<p><code>rzer_*</code>(recognizer) and <code>asor_*</code>(accessor) are got from <code>t1_sort</code>.</p>
<pre><code class="language-ocaml"># #show t1;;
type nonrec t1 = Foo of int * string | Bar of int

# let rzer_foo, rzer_bar = 
  match Datatype.get_recognizers t1_sort with 
  | [ rzer_foo; rzer_bar ] -&gt; (rzer_foo, rzer_bar) 
  | _ -&gt; failwith "recogniziers mismatch";;
val rzer_foo : FuncDecl.func_decl = &lt;abstr&gt;
val rzer_bar : FuncDecl.func_decl = &lt;abstr&gt;

# let (asor_foo_0, asor_foo_1), asor_bar_0 = 
  match Datatype.get_accessors t1_sort with 
  | [ [ asor_foo_0; asor_foo_1 ]; [ asor_bar_0 ] ] -&gt; ((asor_foo_0, asor_foo_1), (asor_bar_0)) 
  | _ -&gt; failwith "accessors mismatch";;
val asor_foo_0 : FuncDecl.func_decl = &lt;abstr&gt;
val asor_foo_1 : FuncDecl.func_decl = &lt;abstr&gt;
val asor_bar_0 : FuncDecl.func_decl = &lt;abstr&gt;
</code></pre>
<p>Recognizers share the shape of variant cases. Accessors share the shape of variant cases and the inner payload types. It's also the same shape with the constructors.</p>
<pre><code class="language-ocaml"># let ei = FuncDecl.apply rzer_foo [e1_z3];;
val ei : Expr.expr = &lt;abstr&gt;

# Expr.to_string ei;;
- : string = "((_ is Foo) (Foo 42 \"camel\"))"
</code></pre>
<p>Here comes the subtle question. <code>FuncDecl.apply</code> builds a function application in Z3 land, but it's just an unevaluated expression.</p>
<pre><code class="language-ocaml"># let unbox_bool v = match Boolean.get_bool_value v with | L_TRUE -&gt; true | L_FALSE -&gt; false | _ -&gt; failwith "L_UNDEF";;
val unbox_bool : Expr.expr -&gt; bool = &lt;fun&gt;

# unbox_bool ei;;
Exception: Failure "L_UNDEF".
</code></pre>
<p>It's not a problem for the box direction because we can <strong>evaluate</strong> in OCaml land, box the result, and build the Z3 expression. To force the <strong>evaluation</strong> in Z3 land, we can use <code>Expr.simplify ctx</code>.</p>
<pre><code class="language-ocaml"># let ei' = Expr.simplify ei None;;
val ei' : Expr.expr = &lt;abstr&gt;

# Expr.to_string ei';;
- : string = "true"

# unbox_bool ei';;
- : bool = true
</code></pre>
<p>Now we have all the ingredients to write <code>prj</code> functions in Z3 land and the <code>unbox</code> from Z3 to OCaml.</p>
<pre><code class="language-ocaml"># let is_foo e = FuncDecl.apply rzer_foo [ e ];;
val is_foo : Expr.expr -&gt; Expr.expr = &lt;fun&gt;
# let prj_foo_0 e = FuncDecl.apply asor_foo_0 [ e ];;
val prj_foo_0 : Expr.expr -&gt; Expr.expr = &lt;fun&gt;
# let prj_foo_1 e = FuncDecl.apply asor_foo_1 [ e ];;
val prj_foo_1 : Expr.expr -&gt; Expr.expr = &lt;fun&gt;

# let is_bar e = FuncDecl.apply rzer_bar [ e ];;
val is_bar : Expr.expr -&gt; Expr.expr = &lt;fun&gt;
# let prj_bar_0 e = FuncDecl.apply asor_bar_0 [ e ];;
val prj_bar_0 : Expr.expr -&gt; Expr.expr = &lt;fun&gt;

# let unbox_t1 e = 
      match e with
      | _ when Expr.simplify (is_foo e) None |&gt; unbox_bool -&gt;
          Foo
            ( Expr.simplify (prj_foo_0 e) None |&gt; unbox_int,
              Expr.simplify (prj_foo_1 e) None |&gt; unbox_string )
      | _ when Expr.simplify (is_bar e) None |&gt; unbox_bool -&gt;
          Bar
            ( Expr.simplify (prj_bar_0 e) None |&gt; unbox_int )
      | _ -&gt; failwith "not here";;
val unbox_t1 : Expr.expr -&gt; t1 = &lt;fun&gt;

# unbox_t1 e1_z3;;
- : t1 = Foo (42, "camel")
</code></pre>
<p>All set for our expected functions!</p>
<h2 id="making-z3-datatype-by-fairy-magic"><a class="header" href="#making-z3-datatype-by-fairy-magic">Making Z3 Datatype by fairy magic</a></h2>
<p>If you don't want to write the above functions, just use <code>fairy_z3.ppx</code>. To check the generated function, change <code>[@@deriving ..]</code> to <code>[@@deriving_inline ..] [@@@end]</code>.</p>
<pre><code class="language-ocaml">type t1 = Foo of int * string | Bar of int
[@@deriving z3 ~flag ~bv_width:52]
</code></pre>
<h2 id="summary-and-to-do"><a class="header" href="#summary-and-to-do">Summary and To-do</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Read (ocaml-)z3 source code to understand its datatype API better.</li>
<li><input disabled="" type="checkbox"/>
Support more type constructors in OCaml.</li>
<li><input disabled="" type="checkbox"/>
Allow more customizing for primitives box and unbox function.</li>
<li><input disabled="" type="checkbox"/>
Make it more easier to use.</li>
<li><input disabled="" type="checkbox"/>
Add more testing.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../libraries/argparse.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../core/container-elements.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../libraries/argparse.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../core/container-elements.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" charset="utf-8"></script>
        <script src="../mark.min.js" charset="utf-8"></script>
        <script src="../searcher.js" charset="utf-8"></script>

        <script src="../clipboard.min.js" charset="utf-8"></script>
        <script src="../highlight.js" charset="utf-8"></script>
        <script src="../book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="../asset/mermaid.min.js"></script>
        <script src="../asset/mermaid-init.js"></script>


    </body>
</html>
