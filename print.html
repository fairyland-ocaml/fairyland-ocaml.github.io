<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fairyland OCaml</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="asset/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="SUMMARY.html">Summary</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="libraries/hashcons.html">Understanding Hashcons</a></li><li class="chapter-item expanded affix "><a href="libraries/argparse.html">Understanding Core.Command and Cmdliner</a></li><li class="chapter-item expanded affix "><a href="libraries/z3-datatype.html">Using Z3.Datatype</a></li><li class="chapter-item expanded affix "><a href="core/container-elements.html">What are [@@deriving compare, sexp_of, hash] for?</a></li><li class="chapter-item expanded affix "><a href="internals/polymorphic-compare.html">What is polymorphic compare?</a></li><li class="chapter-item expanded affix "><a href="core/maps-and-hashtables.html">Understanding Data Collections in Core</a></li><li class="chapter-item expanded affix "><div>Using Hashcons</div></li><li class="chapter-item expanded affix "><div>Understanding Fix</div></li><li class="chapter-item expanded affix "><div>Using Fix</div></li><li class="chapter-item expanded affix "><div>Understanding Ocamlgraph</div></li><li class="chapter-item expanded affix "><div>Profiling</div></li><li class="chapter-item expanded affix "><div>Deriving print</div></li><li class="chapter-item expanded affix "><div>Understanding type format6</div></li><li class="chapter-item expanded affix "><div>Understanding module Format</div></li><li class="chapter-item expanded affix "><div>Understanding destructive substitution</div></li><li class="chapter-item expanded affix "><div>Fixed point</div></li><li class="chapter-item expanded affix "><div>Contravariant</div></li><li class="chapter-item expanded affix "><div>Typeclassopedia</div></li><li class="chapter-item expanded affix "><div>OCaml source reading</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fairyland OCaml</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p><a href="SUMMARY.html">Summary</a> This Page</p>
<p><a href="preface.html">Preface</a> Why Fairyland OCaml</p>
<h2 id="section-library-gems"><a class="header" href="#section-library-gems">Section: Library Gems</a></h2>
<p>Good libraries deserve more explanaion.</p>
<p><a href="libraries/hashcons.html">Understanding <code>Hashcons</code></a></p>
<p><a href="libraries/argparse.html">Understanding <code>Core.Command</code> and <code>Cmdliner</code></a></p>
<p><a href="libraries/z3-datatype.html">Using <code>Z3.Datatype</code></a></p>
<h2 id="section-using-core"><a class="header" href="#section-using-core">Section: Using <code>Core</code></a></h2>
<p>More comprehensive discussion after RWO.</p>
<p><a href="core/container-elements.html">What are [@@deriving compare, sexp_of, hash] for?</a></p>
<h2 id="section-ocaml-internals"><a class="header" href="#section-ocaml-internals">Section: OCaml Internals</a></h2>
<p><a href="internals/polymorphic-compare.html">What is polymorphic compare?</a></p>
<h2 id="-under-construction-"><a class="header" href="#-under-construction-">🚧 <strong>Under Construction</strong> 🚧</a></h2>
<p><a href="core/maps-and-hashtables.html">Understanding Data Collections in <code>Core</code></a></p>
<h2 id="-in-my-plan-"><a class="header" href="#-in-my-plan-">📝 <strong>In My Plan</strong> 📝</a></h2>
<p>Section: Library Gems</p>
<p><a href="">Using <code>Hashcons</code></a> (libraries/hashcons-examples.md)</p>
<p><a href="">Understanding <code>Fix</code></a> (libraries/fix.md)</p>
<p><a href="">Using <code>Fix</code></a> (libraries/fix-examples.md)</p>
<p><a href="">Understanding <code>Ocamlgraph</code></a> (libraries/ocamlgraph.md)</p>
<p><a href="">Profiling</a> (topics/profiling.md)</p>
<p>Section: OCaml Internals</p>
<p><a href="">Deriving print</a> (internals/deriving-print.md)</p>
<p><a href="">Understanding type <code>format6</code></a> (internals/type-format6.md)</p>
<p><a href="">Understanding module <code>Format</code></a> (internals/module-format.md)</p>
<p><a href="">Understanding destructive substitution</a> (internals/destructive-substitution.md)</p>
<p>Section: Concepts</p>
<p><a href="">Fixed point</a> (topics/fixed-point.md)</p>
<p><a href="">Contravariant</a> (concepts/contravariant.md)</p>
<p><a href="">Typeclassopedia</a> (concepts/typeclassopedia.md)</p>
<p>Section: Code Reading</p>
<p><a href="">OCaml source reading</a> (reading/ocaml-source-reading.md)</p>
<!-- - https://discuss.ocaml.org/t/readable-ml-ocaml-sml-etc-compilers/13318 --><div style="break-before: page; page-break-before: always;"></div><p><img src="img/fairyland-camel.png" alt="Fairyland Camel" /></p>
<h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>Fairyland OCaml <sup class="footnote-reference"><a href="#image">1</a></sup> is a blog by <a href="https://www.prover.me/">Shiwei Weng</a> to write my OCaml experience. I used to share OCaml snippets and understanding in our research group <a href="https://pl.cs.jhu.edu/">JHU PL Lab</a>. I decided to port them here for a <a href="http://carl.flax.ie/dothingstellpeople.html">broader audience</a>. The intuition often comes from my learning and research experience and the fantastic students from two <a href="https://pl.cs.jhu.edu/fpse/">functional</a> <a href="https://pl.cs.jhu.edu/pl/">programming</a> courses at JHU.</p>
<p>The blog name is obviously from <a href="https://dev.realworldocaml.org/">Real World OCaml</a>.</p>
<div class="footnote-definition" id="image"><sup class="footnote-definition-label">1</sup>
<p>The picture <em>Fairyland Camel</em> is generated at <a href="https://www.canva.com/">Canva</a> by my wife.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-hashcons"><a class="header" href="#understanding-hashcons">Understanding <code>Hashcons</code></a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p><em>Aside</em>. Data, value, object, component in this post means the same thing but from different perspectives.</p>
<p><em>Folklore</em>. Hash-consing, as the name may suggest, is a hash value cons-ed (appended) after the immutable data (hash key). The immediate benefit is to reuse the hash value for the unchanged data. When used in recursive datatypes, the hash value of a data can be computed from the new payload part and the recursive part whose hash value is already cons-ed.</p>
<p><em>One-step further</em>. It's obvious hash-consing is straightforward for immutable data. However, with immutable data, more aggresive designs can be made. Hash-consing libraries in real-world usually coincide with <a href="https://en.wikipedia.org/wiki/Flyweight_pattern">Flyweight pattern</a>. They have the same targets:</p>
<ol>
<li>Encapsulate the object creation so that any distinct object is created just once.</li>
<li>Generate and save a <strong>unique id</strong> to identify distinct objects.</li>
<li>Save the hash value in the objects and choose a hash function that is aware of the saved hash values for its recursive components.</li>
</ol>
<h2 id="some-concept-or-implementation-details"><a class="header" href="#some-concept-or-implementation-details">Some Concept (or Implementation) Details</a></h2>
<p><em>Hash functions</em>. With a unique id cons-ed, the datatype can provide a new <code>equal</code> function and a new <code>hash</code> function based on this id. In whole scenarios, three <code>hash</code> functions can be used.</p>
<ol>
<li>Global <code>hash</code>. Language provide e.g. <code>Hashtbl.hash</code>. It's used internally for convenience.</li>
<li>Data's <code>hash</code>. The hash function for your hash-consed data provided by users.</li>
<li>Hash-consing library <code>hash</code>. The hash function for your hash-consed data provided by the library.</li>
</ol>
<p>The existence and difference between <strong>2</strong> and <strong>3</strong> is not so clear depending on the library design. However, the ultimate target is to provide a better <strong>2</strong> with or without <strong>3</strong> than the old structural <code>hash</code>.</p>
<p><em>Weak references</em>. Hash-consing library needs to provide an internal store to save the unique objects. This storage can be a <em>weak</em> array or a <em>weak</em> hash table. The internal storage should be <em>weak</em> because it should not prevent the garbage collection if any elements are not used outside.</p>
<p><em>Hash collision</em>. Hash collision and hash resize is handled during the process to generate the unique id with the internal storage. The data's <code>equal</code> and data's <code>hash</code> function will be used. Data's <code>hash</code> collision outside of the internal storage is not concerned here.</p>
<p><em>Structural equality</em>. A natural consequence of unique objects and ids is the structural equality check between two values can be replaced by physical equality. Refresh: structural equality checks whether two values per-component of their structures. Physical equality checks whether two values are at the same memory address. If all the objects is created inside the hash consing library, strutural equality can be replaced by phisical equality. <code>=</code> in OCaml approximates a structural equality check. <code>==</code> in OCaml is phisical equality check.</p>
<h2 id="reading-library-code"><a class="header" href="#reading-library-code">Reading library code</a></h2>
<p>Now we are ready to look closely into two OCaml libraries <code>backtracking/ocaml-hashcons</code> (<code>hashcons</code> on opam) and <code>fpottier/fix</code> with <code>Fix.HashCons</code> (<code>fix</code> on opam).</p>
<h3 id="backtrackingocaml-hashcons"><a class="header" href="#backtrackingocaml-hashcons"><code>backtracking/ocaml-hashcons</code></a></h3>
<p>The repo is <a href="https://github.com/backtracking/ocaml-hashcons">backtracking/ocaml-hashcons</a>.</p>
<p><a href="https://github.com/backtracking/ocaml-hashcons/blob/master/hashcons.mli"><code>hashcons.mli</code></a> defines the type:</p>
<pre><code class="language-ocaml">type +'a hash_consed = private {
  hkey: int;
  tag : int;
  node: 'a;
}
</code></pre>
<p>It's a bit subtle since <code>hkey</code> is computed <em>value</em> from the user-provided <code>H.hash</code> on the data before adding to the internal store. <code>tag</code> is the unique id which is either old from a previous object or new if added. <code>node</code> is the data before hash-consed.</p>
<p>The following code snippets are from <a href="https://github.com/backtracking/ocaml-hashcons/blob/master/test.ml"><code>test.ml</code></a> :</p>
<pre><code class="language-ocaml">open Hashcons

(* a quick demo of Hashcons using lambda-terms *)

type node =
  | Var of string
  | App of term * term
  | Lam of string * term
and term = node hash_consed

(* the key here is to make a O(1) equal and hash functions, making use of the fact that sub-terms are already hash-consed and thus we can 
   1. use == on sub-terms to implement equal
   2. use .tag from sub-terms to implement hash 
   *)
module X = struct
  type t = node
  let equal t1 t2 = match t1, t2 with
    | Var s1, Var s2 -&gt; s1 = s2
    | App (t11, t12), App (t21, t22) -&gt; t11 == t21 &amp;&amp; t12 == t22
    | Lam (s1, t1), Lam (s2, t2) -&gt; s1 = s2 &amp;&amp; t1 == t2
    | _ -&gt; false
  let hash = function
    | Var s -&gt; Hashtbl.hash s
    | App (t1, t2) -&gt; t1.tag * 19 + t2.tag
    | Lam (s, t) -&gt; Hashtbl.hash s * 19 + t.tag
end
module H = Make(X)

let ht = H.create 17
let var s = H.hashcons ht (Var s)
let app t1 t2 = H.hashcons ht (App (t1,t2))
let lam s t = H.hashcons ht (Lam (s,t))

let x = var "x"
let delta = lam "x" (app x x)
let omega = app delta delta

let () = assert (var "x" == x)
let () = assert (app x x == app x x)
</code></pre>
<p><code>X.hash</code> is the data's <code>hash</code>. Global <code>hash</code> is used both in <code>X.hash</code> inside of <a href="https://github.com/backtracking/ocaml-hashcons/blob/872594154dd263334a8f79822f99f1065832d383/hashcons.ml#L110"><code>H.hashcons</code></a>. <code>X.equal</code> uses physical equality for objects. <code>X.hash</code> also uses the unique ids for components. The last two <code>assert</code>s check the objects created at different application shares the same memory addresses.</p>
<p>Module <code>Hashcons</code> also provides <code>Hset</code> and <code>Hmap</code>. They're external containers which is aware of your hash-consed data. Don't confuse them with the internal storage, which is also a hash-based container.</p>
<h3 id="fpottierfix"><a class="header" href="#fpottierfix"><code>fpottier/fix</code></a></h3>
<p>The repo is <a href="https://gitlab.inria.fr/fpottier/fix">fpottier/fix</a>.</p>
<p><code>Fix.HashCons</code>(<a href="https://gitlab.inria.fr/fpottier/fix/-/blob/master/src/HashCons.ml">ml</a>,<a href="https://gitlab.inria.fr/fpottier/fix/-/blob/master/src/HashCons.mli">mli</a>) looks very lightweighted because the internal storage is achieved by another module <code>Fix.MEMOIZER</code>.</p>
<pre><code class="language-ocaml">type 'data cell =
  { id: int; data: 'data }
</code></pre>
<p><code>id</code> is the unique id while <code>data</code> is your datatype to hash-cons. The another difference worth mentioning is with <code>backtracking/ocaml-hashcons</code> the user is in change of the objects pool getting from <code>H.create</code> while with <code>Fix.HashCons</code> the pool is shared. It's explained in <a href="https://gitlab.inria.fr/fpottier/fix/-/blob/master/src/HashCons.ml?ref_type=heads#L19">HashCons.ml</a>.</p>
<pre><code class="language-ocaml">(* M : MEMOIZER *)
let make =
    M.memoize (fun data -&gt; { id = gensym(); data })
</code></pre>
<p><code>MEMOIZER</code> is a module relying on the user-provide <code>Map.S</code> which contains <code>find</code> and <code>add</code>. No data's <code>hash</code> is required, but making <code>MEMOIZER</code> requires a <code>HashedType</code>. The result module of <code>HashCons.Make</code> provides a <code>hash</code> which relies on the unique id.</p>
<p>The demo code <a href="https://gitlab.inria.fr/fpottier/fix/-/blob/master/demos/hco/HashConsDemo.ml">demos/hco
HashConsDemo.ml</a> is challenging to read if one is not aware of these <code>hash</code> functions in use.</p>
<pre><code class="language-ocaml">open Fix

module MySkeleton = struct
  type 'a t =
    | Leaf
    | Node of int * 'a * 'a

  let equal equal sk1 sk2 =
    match sk1, sk2 with
    | Leaf, Leaf -&gt;
        true
    | Node (x1, l1, r1), Node (x2, l2, r2) -&gt;
        x1 = x2 &amp;&amp; equal l1 l2 &amp;&amp; equal r1 r2
    | Node _, Leaf
    | Leaf, Node _ -&gt;
        false

  let hash hash sk =
    match sk with
    | Leaf -&gt;
        0
    | Node (x, l, r) -&gt;
        x + hash l + hash r
end

type tree =
  skeleton HashCons.cell

and skeleton =
  S of tree MySkeleton.t [@@unboxed]

module M =
  HashCons.ForHashedTypeWeak(struct
    type t = skeleton
    let equal (S sk1) (S sk2) =
      MySkeleton.equal HashCons.equal sk1 sk2
    let hash (S sk) =
      MySkeleton.hash HashCons.hash sk
  end)

let leaf () : tree =
  M.make (S MySkeleton.Leaf)

let node x l r : tree =
  M.make (S (MySkeleton.Node (x, l, r)))

let example() =
  node 0
    (leaf())
    (leaf())

let () =
  assert (example() == example());
  Printf.printf "Size of example tree is %d.\n" (size (example()));
  print_endline "Success."
</code></pre>
<p><code>MySkeleton</code> provides <code>equal</code> and <code>hash</code>, which require another <code>equal</code> and <code>hash</code> as arguments respectively. The hash-consing aware <code>equal</code> and <code>hash</code> is provided in <code>HashCons.ForHashedTypeWeak</code>. The resulting code shares the same motivation as the previous demo.</p>
<h2 id="summary-and-questions-to-do"><a class="header" href="#summary-and-questions-to-do">Summary and Questions (To-do)</a></h2>
<p>I am short on time to polish the post and complete all my to-do now. My motivation is the fixed point computation runs very slow on several test cases, and the profiling results show it's doing too much repeated structural hashing. The post mainly shares how to understand hash-consing libraries. <em>If I may</em>, I will rename both <code>hash consing</code> or <code>flyweight</code> to <code>with_unique</code> or <code>with_uid</code>.</p>
<p>Besides these two OCaml libraries, I also refer to <a href="https://en.wikipedia.org/wiki/Hash_consing">wiki/Hashconing</a> and papers</p>
<ul>
<li>Sylvain Conchon and Jean-Christophe Filliâtre. Type-Safe Modular Hash-Consing. In ACM SIGPLAN Workshop on ML, Portland, Oregon, September 2006.</li>
<li>Implementing and reasoning about hash-consed data structures in Coq</li>
</ul>
<p>How to bring hash-consing to <code>Core</code> is my immediate problem.</p>
<p>Furthermore, as string intern is widely used for many languages, why is hash-consing not the default implementation inside OCaml compilers?</p>
<p>The functions on the raw types need to be reimplemented with the hash cons-ed type with just tedious fmap. Is it another case for the <em>Expression Problem</em> or <em>Open Recursion</em>?</p>
<p>I am also interested in the implementation of <a href="https://github.com/camlp5/pa_ppx_hashcons">camlp5/pa_ppx_hashcons</a> and <a href="https://coq.inria.fr/doc/master/api/coq-core/Hashcons/index.html">coq-core/Hashcons</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-corecommand-and-cmdliner"><a class="header" href="#understanding-corecommand-and-cmdliner">Understanding <code>Core.Command</code> and <code>Cmdliner</code></a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Command-line parse libraries e.g. <code>Core.Command</code> and <code>Cmdliner</code> are notoriously difficult to understand and use. The tension may come from people require a quick solution, while both these libraries target to be full-feathered tools with abstractions and concepts. This post aims to provide an understanding guide for them. Their official tutorials are at <a href="https://dev.realworldocaml.org/command-line-parsing.html">RWO/Command-Line Parsing</a> and <a href="https://erratique.ch/software/cmdliner/doc/tutorial.html">cmdliner/tutorial</a>. I hope you can be much clear to jump back to them after reading this guide.</p>
<h2 id="four-concepts"><a class="header" href="#four-concepts">Four Concepts</a></h2>
<p>Both libraires provide four levels of concepts:</p>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>Stage</th><th>Composable</th><th>Core.Command</th><th>Cmdliner</th></tr></thead><tbody>
<tr><td>Argument Parser</td><td>Step 3</td><td>no</td><td><code>'a Arg_type.t</code></td><td><code>'a Arg.conv = 'a parser * 'a printer</code></td></tr>
<tr><td>Argument Handler</td><td>Step 3</td><td>yes</td><td><code>'a Param.t</code></td><td><code>'a Term.t</code></td></tr>
<tr><td>Command Item</td><td>Step 2</td><td>yes</td><td><code>unit Command.t</code></td><td><code>'a Cmd.t</code></td></tr>
<tr><td>Driver</td><td>Step 1</td><td>no</td><td><code>Command.run</code></td><td><code>Cmd.eval</code>,  <code>Cmd.eval_value</code></td></tr>
</tbody></table>
</div><div style="text-align: center"> Table 1 - Concepts for Core.Command and Cmdliner </div>
<p><strong>Argument Parser</strong> provides functions to parse a raw string to the expected type <code>'a</code>. They both provide parsers inside <a href="https://v3.ocaml.org/p/core/latest/doc/Core/Command/Spec/index.html#val-string">Core/Command/Spec</a> and <a href="https://erratique.ch/software/cmdliner/doc/Cmdliner/Arg/index.html#converters">Cmdliner/Predefined_converters</a> for common types. <code>Cmdliner.Arg.conv</code> is a pair of a parser with a printer.</p>
<p><strong>Argument Handler</strong> wraps a parser with extra properties to handle command-line argument e.g. whether it's required or optional, whether it's repeated, with a flag or not, the doc string for it. <strong>Argument Handler</strong> may not need <strong>Parsing</strong> in examples that a flag argument carries no values. The existence or not means a boolean parameter e.g. <code>-v</code> (rather than <code>-log=WARNING</code>).</p>
<p>In both libraries, <strong>Argument Handlers</strong> are not directed used by <strong>Drivers</strong>. <strong>Argument Handlers</strong> are packed into a <strong>Command Item</strong>, and then <strong>drivers</strong> take <strong>Command Item</strong> and perform the real parsing work. A <strong>Command Item</strong> for a whole sub-command e.g. <code>push ...</code> in <code>git push ...</code>. You may have other sub-commands like <code>git clone</code>, <code>git pull</code>, and you need to group these <strong>Command Items</strong> into a compound <strong>Command Item</strong>.</p>
<p>In Table 1, The Column <strong>Stage</strong> lists the time order during a real command-line parsing.</p>
<ul>
<li>Step 1: <strong>Driver</strong> are usually the unique top function of your program. It takes the <code>Sys.argv</code> and invodes your <strong>Command Item</strong>.</li>
<li>Step 2: <strong>Driver</strong> dispatches to the <strong>Command Item</strong>.</li>
<li>Step 3: <strong>Argument Handler</strong> performs the parsing and handling, with the <strong>Argument Parser</strong> in it if having one.</li>
</ul>
<h2 id="driver-functions"><a class="header" href="#driver-functions">Driver functions</a></h2>
<p><code>Core.Command</code> can only build up to a <code>Command.t</code>. It doesn't provide any driver functions. The <strong>driver function</strong> <code>Core.Command.run</code> is defined in another library <code>core_unix.command_unix</code>. It takes the <code>Core.Command.t</code> and start the work.</p>
<p><code>Cmdliner</code> has a variant of <strong>driver functions</strong> e.g. <code>Cmd.eval</code> and <code>Cmd.eval_value</code>. Since they're supposed to be the unique top functions, <code>Cmd.eval</code> returns a <code>unit</code> while <code>Cmd.eval</code> returns a <code>int</code> (standard error code) that is used by <code>exit</code>.</p>
<p>It's a common myth that people seek to get the unboxed parsed result. Such a function is not even provided in <code>Core.Command</code>. It's do-able with <code>Cmdliner.Cmd.eval_value : ... -&gt; ?argv:string array -&gt; 'a Cmd.t -&gt; ('a Cmd.eval_ok, Cmd.eval_error) result</code>. However, you need to tokenize to get <code>argv</code> yourself (Imparient readers can jump to Section <a href="libraries/argparse.html#elimination">Elimination</a>).</p>
<h2 id="diagrams-for-corecommand-and-cmdliner"><a class="header" href="#diagrams-for-corecommand-and-cmdliner">Diagrams for <code>Core.Command</code> and <code>Cmdliner</code></a></h2>
<p>Both <code>Core.Command</code> and <code>Cmdliner</code> have two-layered compositional datatypes. An element in the inner layer is to parse one key-value pair (or key-only or value-only). For example, we're going to parse <code>-v -a=1 -b=t 42</code>.</p>
<p>The inner layer for <code>Core.Command</code> is a compositional <code>Param.t</code>. We will have four <code>Param.t</code> that are</p>
<ul>
<li><code>bool Param.t</code> for <code>-v</code></li>
<li><code>int Param.t</code> for <code>-a=1</code> in which a <code>int Arg_type</code> to parse <code>1</code></li>
<li><code>string Param.t</code> for <code>-b=t</code> in which a <code>string Arg_type</code> to parse <code>t</code></li>
<li><code>int Param.t</code> for <code>42</code> in which a <code>int Arg_type</code> to parse <code>42</code></li>
</ul>
<p>The inner layer for <code>Cmdliner</code> is a compositional <code>Term.t</code>. We will have four <code>Term.t</code> that are</p>
<ul>
<li><code>bool Term.t</code> for <code>-v</code></li>
<li><code>int Term.t</code> for <code>-a=1</code> in which a <code>int Arg.conv</code> to parse <code>1</code></li>
<li><code>string Term.t</code> for <code>-b=t</code> in which a <code>string Arg.conv</code> to parse <code>t</code></li>
<li><code>int Term.t</code> for <code>42</code> in which a <code>int Arg.conv</code> to parse <code>42</code></li>
</ul>
<p>The inner layer data are wrapped into outer layer data <code>Core.Command.t</code> or <code>Cmdliner.Cmd.t</code> via packing function <code>Core.Command.basic</code> or <code>Cmdliner.Cmd.v</code>. A outer layer data is usually used for argparsing one command-line case. It is also composable and is used to group sub-commands. <a href="https://v3.ocaml.org/p/core/latest/doc/Core/Command/index.html#val-group"><code>Core.Command.group</code></a> takes <code>(string * Core.Command.t) list</code> and returns a <code>Core.Command.t</code>. <a href="https://erratique.ch/software/cmdliner/doc/Cmdliner/Cmd/index.html#val-group"><code>Cmdlinder.Cmd.group</code></a> takes <code>Cmdliner.Cmd.t list</code> and returns a <code>Cmdliner.Cmd.t</code>.</p>
<p>Their diagrams are very alike in the respective of our <strong>four concepts</strong>. A rectangle corresponds to a type. An edge is a function that transforms datatype. A rounded rectangle is also a function but at an endpoint (It's rare. Only two driver functions and one <code>Arg.flag</code>). Four compositional datatypes <code>Param.t</code> <code>Command.t</code> <code>Term.t</code> <code>Cmd.t</code> should be in stacked rectangles (but here I just use a rectangle with double edges). I omit the doc-related components to make it clear.</p>
<pre class="mermaid">---
title: Figure 1.1 - Diagram for Core.Command
---
graph LR
  subgraph at [Argument Parser]
    AT[Arg_type.t]
  end

  subgraph sp [Argument Handler]
    subgraph fa [Flag &amp; Anons]
      CA1[Anons.t]
      CF1[Flag.t]
      CF2[no_arg : Flag.t]
    end

    AT --&gt; |&quot;Anons.(%:)&quot;| CA1
    AT --&gt; |Param.required| CF1

    P0[[Param.t]] --&gt; |&quot;Param.map&quot;| P0

    CA1--&gt; |Param.anon| P0
    CF1 --&gt; |Param.flag| P0
    CF2 --&gt; |Param.flag| P0
  end
  
  subgraph sg [Command Item]
    C0[[Command.t]] --&gt; | Command.group | C0
  end

  P0 --&gt; |Command.basic| C0

  subgraph sd [Driver]
    direction LR
    Cr(Command.run)
    C0 -.-&gt; Cr
  end
</pre>
<pre class="mermaid">---
title: Figure 1.2 - Diagram for Cmdliner
---
graph LR
  subgraph ap [Argument Parser]
    AC[Arg.conv]
  end

  AC --&gt; |Arg.pos| AT1
  AC --&gt; |Arg.opt| AT2

  subgraph sa [Argument Handler]
    subgraph at [Arg.t]
      AT1[Arg.t]
      AT2[Arg.t]
      AT3(Arg.flag ~&gt; Arg.t)
    end

    AT1 --&gt; |Arg.value| P0
    AT2 --&gt; |Arg.value| P0
    AT3 --&gt; |Arg.value| P0

    P0[[Term.t]] --&gt; |&quot;Term.($)&quot;| P0
  end

  P0 --&gt; |Cmd.v| C0

  subgraph sg [Command Item]
    direction LR
    C0[[Cmd.v]] --&gt; |Cmd.group| C0
  end

  subgraph sd [Driver]
    direction LR
    Cr(Cmd.eval)
    Cv(Cmd.eval_value)
    C0 .-&gt; Cr
    C0 .-&gt; Cv
  end
</pre>
<h2 id="how-paramt-and-termt-are-made"><a class="header" href="#how-paramt-and-termt-are-made">How <code>Param.t</code> and <code>Term.t</code> are made</a></h2>
<p>A <code>Core.Command.t</code> consists of the <em>flagged</em> parameters and <em>anonymous</em> (flag-less) parameters. A <code>Cmdlinder.t</code> is consists of <em>optional arguments</em> and <em>positional arguments</em>. They are <strong>Argument Handlers</strong>. Note <strong>Argument Handlers</strong> use <strong>Argument Parsers</strong>.</p>
<p>In <code>Core.Command</code>, A primitive <code>'a Param.t</code> can made up from ingridients</p>
<ol>
<li><code>'a Arg_type.t</code> parses <code>string</code> to <code>'a</code></li>
<li><code>'a Flag.t</code> can wrap <code>'a Arg_type.t</code> as <code>required</code>, <code>optional</code>, or <code>optional_with_default</code></li>
<li><code>'bool Flag.t</code> requires no <code>'a Arg_type.t</code>. Therefore its existence denotes a <code>true</code> or <code>false</code></li>
<li><code>'a Anons.t</code> which wraps <code>'a Arg_type.t</code></li>
<li><code>Param.flag</code> makes <code>'a Flag.t</code> a <code>'a Param.t</code></li>
<li><code>Param.anon</code> makes <code>'a Anons.t</code> a <code>'a Param.t</code></li>
</ol>
<p>In <code>Cmdlinder</code>, the ingridients to make up a primitive <code>'a Term.t</code> are:</p>
<ol>
<li><code>'a Arg.conv</code> defines both a parser and a printer for <code>'a</code></li>
<li><code>Arg.opt</code> wraps <code>'a Arg.conv</code> an optional flagged argument <code>'a Arg.t</code>.</li>
<li><code>Arg.pos</code> wraps <code>'a Arg.conv</code> and makes a positional argument at certain index <code>'a Arg.t</code></li>
<li><code>Arg.flag</code> makes a pure flag optional argument <code>bool Arg.t</code></li>
<li><code>Arg.value</code> makes <code>'a Arg.t</code> a <code>'a Term.t</code></li>
</ol>
<p>The listing and the diagram are not complete, but they are sufficient to illuminate.</p>
<h2 id="pack-argument-handler-to-command-item"><a class="header" href="#pack-argument-handler-to-command-item">Pack <strong>Argument Handler</strong> to <strong>Command Item</strong></a></h2>
<p><strong>Driver</strong> functions takes a <strong>Command Item</strong> packed from a <strong>Argument Handler</strong>. <code>Param.t</code> and <code>Term.t</code> can compose just like parser combinator or prettyprinter. They should be <code>Applicative</code> (or also <code>Contravariant</code> ?)</p>
<h3 id="pack-commandparamt-to-commandt"><a class="header" href="#pack-commandparamt-to-commandt">Pack <code>Command.Param.t</code> to <code>Command.t</code></a></h3>
<p>The pack function for <code>Command</code> is <code>Command.basic</code>.</p>
<pre><code class="language-ocaml"># #require "core";;
# open Core;;
# Command.Param.map;;
- : 'a Command.Spec.param -&gt; f:('a -&gt; 'b) -&gt; 'b Command.Spec.param = &lt;fun&gt;

# #show Command.basic;;
val basic : unit Command.basic_command

# #show Command.basic_command;;
type nonrec 'result basic_command =
    summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt;
    (unit -&gt; 'result) Command.Spec.param -&gt; Command.t
</code></pre>
<p>Type <code>Command.Spec.param</code> is an alias for <code>Command.Param.t</code>. We can see the types for first argument and the return type of <code>Command.Param.map</code>, and the second-to-last argument of <code>Command.basic_command</code>, are all <code>Command.Param.t</code>. <code>'result</code> is set to be <code>unit</code> in <code>Command.basic</code>.</p>
<p>The task left for users is to provide a function that maps parsed result <code>'a Param.t</code> to <code>(unit -&gt; unit) Param.t</code>.</p>
<p>The following two lines are equal. It's a partially applied <code>Param.map</code> from <code>string Param.t</code> to an unknown <code>~f : string -&gt; '_weak</code>:</p>
<pre><code class="language-ocaml"># Command.Param.(%:);;
- : string -&gt; 'a Command/2.Arg_type.t -&gt; 'a Command.Spec.anons = &lt;fun&gt;

# Command.Param.string;;
- : string Command/2.Arg_type.t = &lt;abstr&gt;

# Command.Param.(map (anon ("filename" %: string)));;
- : f:(string -&gt; '_weak1) -&gt; '_weak1 Command.Spec.param = &lt;fun&gt;

# Command.(let s : string Param.Arg_type.t = Param.string in let a = Param.(%:) "filename" s in Param.map (Param.anon a));;
- : f:(string -&gt; '_weak2) -&gt; '_weak2 Command.Spec.param = &lt;fun&gt;
</code></pre>
<p>In the following example of <code>Command.basic</code>, our function <code>(fun file () -&gt; ignore file)</code> satisfied the type requirement. The observation here is <code>Command.basic</code> requires an argument of type <code>(unit -&gt; unit) Command.Spec.param</code>. The user <em>comsume-all-parsed</em> code is usually like <code>Param.map a_b_c_param ~f:(fun a b c () -&gt; ...; () ) : (unit -&gt; unit) Command.Spec.param</code>. The parsed result is passed before the last argument <code>()</code>.</p>
<pre><code class="language-ocaml"># Command.basic ~summary:"fairy file" Command.Param.(map (anon ("filename" %: string)) ~f:(fun file () -&gt; ignore file));;
- : Command.t = &lt;abstr&gt;
</code></pre>
<p>To make it familiar to RWO readers, we use <code>let%map_open</code> instead of <code>Param.map</code>. The code is equivalent to the above one:</p>
<pre><code class="language-ocaml"># #require "ppx_jane";;

# let%map_open.Command file = (anon ("filename" %: string)) in file;;
- : string Command.Spec.param = &lt;abstr&gt;

# Command.basic ~summary:"fairy file" (let%map_open.Command file = (anon ("filename" %: string)) in fun () -&gt; ignore file);;
- : Command.t = &lt;abstr&gt;
</code></pre>
<h3 id="pack-cmdlinertermt-to-cmdlinercmdt"><a class="header" href="#pack-cmdlinertermt-to-cmdlinercmdt">Pack <code>Cmdliner.Term.t</code> to <code>Cmdliner.Cmd.t</code></a></h3>
<p><code>Cmdliner</code> uses <em>pure</em> (<code>Term.const : 'a -&gt; 'a t</code>) and <em>ap</em> (<code>Term.($) : ('a -&gt; 'b) t -&gt; 'a t -&gt; 'b t</code>) to compose <code>Term.t</code>. Unlike <code>Command.basic</code>, the user <em>comsume-all-parsed</em> code is usually like <code>Term.(const (fun a b c -&gt; ...; () )) $ a_param $ b_param $ c_param : unit Term.t</code>. <code>Term.v</code> packs this value to get a <code>Cmd.t</code>, then this <code>Cmd.t</code> can be used in the driver function <code>Cmd.eval</code>.</p>
<pre><code class="language-ocaml"># #require "cmdliner";;
# open Cmdliner;;

# Arg.(&amp;);;
- : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;

# Arg.value;;
- : 'a Cmdliner.Arg.t -&gt; 'a Term.t = &lt;fun&gt;

# Arg.string;;
- : string Arg.converter = (&lt;fun&gt;, &lt;fun&gt;)

# let file = Arg.(value &amp; pos 0 string "default_name" (Arg.info []));;
val file : string Term.t = &lt;abstr&gt;

# Cmd.v (Cmd.info "fairy file") Term.((const (fun filename -&gt; ignore filename)) $ file );;
- : unit Cmd.t = &lt;abstr&gt;
</code></pre>
<p>The difference between their approaches is <code>Command</code> puts the <em>comsume-all-parsed</em> function at last while <code>Cmdliner</code> puts it at first. They both use functional jargons e.g. <code>let%map_open</code>, <code>Anon.(%:)</code>, <code>Arg.(&amp;)</code> and <code>Term.($)</code>. They help to compact the code, at the cost of confusing newcomers.</p>
<h2 id="syntax-for-command-line-languages"><a class="header" href="#syntax-for-command-line-languages">Syntax for Command-line Languages</a></h2>
<p>It's not explicitly specified, but their design and APIs suggest (or <em>check</em>) possible syntax for the command-line languages. e.g. for the flag-less parts, <code>Command</code> treats them as anonymous arguments and allow the a sequence of them. The run-time validity of <code>Param.t</code> is less powerful than its static type. In this example, Anonymous <code>int</code> after a list of anonymous <code>string</code> causes an exception for its syntax.</p>
<pre><code class="language-ocaml"># let my_param = 
    (let%map_open.Command str_lst = anon (sequence ("str" %: string)) 
    and extra_int = anon ("int" %: int) in 
    fun () -&gt; ());;
val my_param : (unit -&gt; unit) Command.Spec.param = &lt;abstr&gt;

# Command.basic ~summary:"my_param" my_param ;;
Exception:
Failure
 "the grammar [STR ...] INT for anonymous arguments is not supported because there is the possibility for arguments (INT) following a variable number of arguments ([STR ...]).  Supporting such grammars would complicate the implementation significantly.".
Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
Called from Base__List0.fold in file "src/list0.ml", line 37, characters 27-37
Called from Command.Anons.Grammar.concat in file "command/src/command.ml", line 1000, characters 10-729
Called from Command.basic in file "command/src/command.ml", line 2373, characters 14-22
Called from Topeval.load_lambda in file "toplevel/byte/topeval.ml", line 89, characters 4-14
</code></pre>
<p><code>Cmdliner</code> treats flag-less parts as positional arguments. The manual warns it's the user's <em>duty</em> to ensure the unique use of a position. <code>Arg</code> provides functions to either preciously points to one position index, or to range all, or to cover the left/right to a given position index. Duplication of position index will trigger run-time exception.</p>
<pre><code class="language-ocaml"># let top_t =
  let ai = Arg.info [] in
  let str_lst : string list Term.t = Arg.(value &amp; pos_all string [] ai) in
  let extra_int : int Term.t = Arg.(value &amp; pos 1 int 0 ai) in
  let handle_all : (string list -&gt; int -&gt; unit) Term.t =
    Term.const @@ fun _str_list _extra_int -&gt; ()
  in
  Term.(handle_all $ str_lst $ extra_int);;
val top_t : unit Term.t = &lt;abstr&gt;

# let c =
  let i = Cmd.info "" in
  Cmd.v i top_t ;;
val c : unit Cmd.t = &lt;abstr&gt;

# Cmd.eval_value ~argv:[| "a"; "2" |] c;;
- : (unit Cmd.eval_ok, Cmd.eval_error) result = Stdlib.Ok (`Ok ())

# Cmd.eval_value ~argv:[| "a"; "b" |] c;;
: invalid value 'b', expected an integer
Usage:  [OPTION]… [ARG]…
Try ' --help' for more information.
- : (unit Cmd.eval_ok, Cmd.eval_error) result = Stdlib.Error `Parse
</code></pre>
<h2 id="summary-and-questions"><a class="header" href="#summary-and-questions">Summary and Questions</a></h2>
<p>To recap, after skipping documenting, escaping, error code, auto-completing, two of the most popular command-line libraries <code>Core.Command</code> and <code>Cmdliner</code> can be grasped via four concepts i.e. <strong>Argument Parser</strong>, <strong>Argument Handler</strong>, <strong>Command Item</strong>, and <strong>Driver</strong>. The <a href="libraries/argparse.html#diagrams-for-corecommand-and-cmdliner">diagram</a> not only shows their internal relation, but also reveal the similarity between them. I don't have time to re-comment all their documents and tutorials from my viewpoint, but you're well equipped to go back for them ((for <a href="https://dev.realworldocaml.org/command-line-parsing.html"><code>Command</code></a> and for <a href="https://erratique.ch/software/cmdliner/doc/tutorial.html"><code>Cmdliner</code></a>)) after this post.</p>
<p>Explicit syntax for for command-line languages and static safety typed parsing arise very interesting problems to me. I will delve into it in future posts.</p>
<h2 id="elimination"><a class="header" href="#elimination">Elimination</a></h2>
<p>For command-line parsing, OCaml has build-in <code>Sys.argv</code> and standard library <code>Arg</code> module (<a href="https://ocaml.org/docs/cli-arguments">tutorial</a>).</p>
<p>⚠️ We can let <code>Core.Command</code> return the parsed result with a mutable reference, even its pack function and driver function requires a <code>unit</code> return value. When a functional program is <a href="https://dl.acm.org/doi/pdf/10.1145/317636.317775">not</a> a functional program?</p>
<pre><code class="language-ocaml"># let store = ref "" in 
  Command.basic ~summary:"fairy file" Command.Param.(map (anon ("filename" %: string)) ~f:(fun file () -&gt; store := file; ()));;
- : Command.t = &lt;abstr&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-z3datatype"><a class="header" href="#using-z3datatype">Using <code>Z3.Datatype</code></a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>This post is for explaining some concepts and show usage for library <a href="https://opam.ocaml.org/packages/z3/"><code>ocaml-z3</code></a> and my library <a href="https://github.com/arbipher/ocaml_fairy_z3"><code>fairy_z3</code></a>. My long-time goal is to make <em>Solve Anything</em> easy in OCaml, and this is just a first step.</p>
<p>Roughly, z3 has coresponding data structures for <em>expressions</em>, <em>primitive types</em> and <em>datatypes</em>, as like these in OCaml. I will not discuss the details of <em>logic</em> or <em>theory</em> used in a SMT solver Z3. We can just treat it as versatile library.</p>
<p>To clarify,</p>
<ul>
<li><em>primitive types</em> in OCaml, e.g. <code>int</code>, <code>boolean</code>, <code>float</code>, <code>string</code>.</li>
<li><em>datatypes</em> in OCaml, variants or records, <code>type t1 = Foo of int * string | Bar of int</code>, <code>type t2 = {a : int; b : float}</code>.</li>
</ul>
<p>In the current ocaml-z3 implementation, there is just one syntactic type <code>Z3.Expr.expr</code> for all z3 expressions and one syntactic type <code>Z3.Sort.sort</code> for the their types. To make this post more clear, we assume there is a better type definition that carries the correct sort of the expression. e.g. <code>Z3Int 42 : Z3_int_exp</code>. (It could be my second step for the long-time goal). Again,</p>
<ul>
<li><em>primitive types</em> in z3, e.g. <code>Z3_int</code>, <code>Z3_boolean</code>.</li>
<li><em>datatypes</em> in Z3 e.g. <code>Z3_t1</code>, <code>Z3_t2</code>.</li>
</ul>
<p>Both OCaml and z3 provide the ways to construct and operate on primitive types. In OCaml, a datatype is easy to define. However, it takes some effect to construct a datatype with ocaml-z3 and use it. That's what this post and <code>fairy_z3</code> targets.</p>
<h2 id="box-unbox-inject-project"><a class="header" href="#box-unbox-inject-project">Box, Unbox, Inject, Project</a></h2>
<p><img src="libraries/z3-buip.png" alt="Z3-buip" /></p>
<p>(Mermaid cannot handle nicely diagram in this isometric layout so I have to use excalidraw..)</p>
<p>We have four arrow groups:</p>
<ol>
<li>
<p>(Solid green lines) In the OCaml land, <code>inj</code>(inject) and <code>prj</code>(project) are supported by the language. Given the type <code>t1</code> above, <code>inj</code> is to construct from primitive values to a value in type <code>t1</code> and the <code>prj</code> is to pattern match a value in type <code>t1</code>.</p>
</li>
<li>
<p>(Solid red/blue lines) Between the primitive types of OCaml land and Z3 land. We choose the terms <code>box</code> and <code>unbox</code> to describe a value is to/from another representation in the perspective of OCaml. These functions are on-the-shelf.</p>
</li>
</ol>
<pre><code class="language-ocaml">let box_int : int -&gt; Z3.Expr.expr = 
  fun i -&gt;
    Z3.Arithmetic.Integer.mk_numeral_i ctx i

let unbox_int : Z3.Expr.expr -&gt; int =
  fun e -&gt; 
    e |&gt; Z3.Arithmetic.Integer.get_big_int
      |&gt; Big_int_Z.int_of_big_int
</code></pre>
<pre><code class="language-mdx-error">Line 1, characters 22-34:
Error: Unbound module Z3
</code></pre>
<ol start="3">
<li>
<p>(Another solid green lines) In the Z3 land, <code>inj</code> and <code>prj</code> are achievable but tedious to write. We will demonstrate it in the later section and then advocate using <code>fairy_z3.ppx</code> to derive them instead.</p>
</li>
<li>
<p>(Dotten red/blue lines) Between the datatypes of OCaml land and Z3 land. The <code>box</code> and <code>unbox</code> for datatypes are made of the above three groups.</p>
</li>
</ol>
<h2 id="making-z3-datatype-by-hand"><a class="header" href="#making-z3-datatype-by-hand">Making Z3 Datatype by hand</a></h2>
<p>Z3 has <a href="https://microsoft.github.io/z3guide/docs/theories/Datatypes/">tutorial</a> and <a href="https://z3prover.github.io/api/html/ml/Z3.Datatype.html">api manual</a>. Now I cannot remember how I figured out how to use it. Some z3 issues definitely helped.</p>
<p>If you have a glance of its api, you can find <code>constructor</code>, <code>recognizer</code>, <code>accessor</code> as well as <code>sort</code> and <code>func_decl</code>. Conceptually, <code>func_decl</code> are <em>functions</em> in <strong>Z3 land</strong> and <code>sort</code> are <em>types</em> in <strong>Z3 land</strong>. <code>constructor</code>, <code>recognizer</code> and <code>accessor</code> are certain <em>functions</em> and their functionalities are like the OCaml <em>functions</em> around OCaml <em>datatypes</em> but in <strong>Z3 land</strong>.</p>
<p>We first prepare the helper Z3 definitions in the group 2.</p>
<pre><code class="language-ocaml"># #require "z3";;

# open Z3;;

# let ctx = mk_context [];;
val ctx : context = &lt;abstr&gt;
# let int_sort = Arithmetic.Integer.mk_sort ctx;;
val int_sort : Sort.sort = &lt;abstr&gt;
# let int_sort = Arithmetic.Integer.mk_sort ctx;;
val int_sort : Sort.sort = &lt;abstr&gt;
# let string_sort = Seq.mk_string_sort ctx;;
val string_sort : Sort.sort = &lt;abstr&gt;

# let box_int : int -&gt; Z3.Expr.expr = 
  fun i -&gt;
    Z3.Arithmetic.Integer.mk_numeral_i ctx i
val box_int : int -&gt; Expr.expr = &lt;fun&gt;

# let unbox_int : Z3.Expr.expr -&gt; int =
  fun e -&gt; 
    e |&gt; Z3.Arithmetic.Integer.get_big_int
      |&gt; Big_int_Z.int_of_big_int
val unbox_int : Expr.expr -&gt; int = &lt;fun&gt;

# let box_string s = Seq.mk_string ctx s;;
val box_string : string -&gt; Expr.expr = &lt;fun&gt;
# let unbox_string e = Seq.get_string ctx e;;
val unbox_string : Expr.expr -&gt; string = &lt;fun&gt;
</code></pre>
<p>Then we define the example type <code>t1</code>. We also write a few functions <code>ctor_*_ml</code>(constructor), <code>rzer_*_ml</code>(recognizer), <code>asor_*_ml</code>(accessor) in <strong>OCaml land</strong> just for illustrating.</p>
<pre><code class="language-ocaml"># type t1 = Foo of int * string | Bar of int;;
type t1 = Foo of int * string | Bar of int

# let ctor_foo_ml (i,s) = Foo (i,s);;
val ctor_foo_ml : int * string -&gt; t1 = &lt;fun&gt;
# let rzer_foo_ml = function | Foo (_, _) -&gt; true | _ -&gt; false;;
val rzer_foo_ml : t1 -&gt; bool = &lt;fun&gt;
# let asor_foo_0_ml = function | Foo (i, _) -&gt; i | _ -&gt; failwith "only foo";;
val asor_foo_0_ml : t1 -&gt; int = &lt;fun&gt;
</code></pre>
<p>Now we are in <strong>Z3 land</strong>. We can make the constructors and the <em>sort</em>.</p>
<pre><code class="language-ocaml"># Datatype.mk_constructor_s;;
- : context -&gt;
    string -&gt;
    Symbol.symbol -&gt;
    Symbol.symbol list -&gt;
    Sort.sort option list -&gt; int list -&gt; Datatype.Constructor.constructor
= &lt;fun&gt;

# let ctor_foo = Datatype.mk_constructor_s ctx "Foo" 
  (Symbol.mk_string ctx "is-Foo")
  [ Symbol.mk_string ctx "Foo-0"; Symbol.mk_string ctx "Foo-1" ]
  [ Some int_sort; Some string_sort ]
  [ 1; 1 ];;
val ctor_foo : Datatype.Constructor.constructor = &lt;abstr&gt;

# let ctor_bar = Datatype.mk_constructor_s ctx "Bar"
  (Symbol.mk_string ctx "is-Bar")
  [ Symbol.mk_string ctx "Bar-0" ]
  [ Some int_sort ] [ 1 ];;
val ctor_bar : Datatype.Constructor.constructor = &lt;abstr&gt;

# let t1_sort = Datatype.mk_sort_s ctx "t1_sort" [ ctor_foo; ctor_bar ];;
val t1_sort : Sort.sort = &lt;abstr&gt;
</code></pre>
<p>We make a constructor for each variant tag e.g. <code>ctor_foo</code> and in each tag we specify each payload type e.g. <code>int</code> (in `Foo of int * string) its name, sort, and whether it's recursive (non-zero means non-recursive).</p>
<p>A constructor is a variant tag description that used to make a sort. To apply a constructore, we need to first get the associated function a.k.a. <code>func_decl</code> in Z3 land. Then we <em>apply</em> this function in Z3 land via <code>FuncDecl.apply</code>.</p>
<pre><code class="language-ocaml"># let ctor_f_foo = Datatype.Constructor.get_constructor_decl ctor_foo;;
val ctor_f_foo : FuncDecl.func_decl = &lt;abstr&gt;
# let ctor_f_bar = Datatype.Constructor.get_constructor_decl ctor_bar;;
val ctor_f_bar : FuncDecl.func_decl = &lt;abstr&gt;

# let e1_ = Foo (42, "camel");;
val e1_ : t1 = Foo (42, "camel")

# let e1 = ctor_foo_ml (42, "camel");;
val e1 : t1 = Foo (42, "camel")

# let e1_z3 = FuncDecl.apply ctor_f_foo [box_int 42; box_string "camel"];;
val e1_z3 : Expr.expr = &lt;abstr&gt;

# Expr.to_string e1_z3;;
- : string = "(Foo 42 \"camel\")"
</code></pre>
<p>Now we have already make a Z3 expression of <code>t1_sort</code>. We can also make constraint and solve on it. e.g. we can ask to solve <code>(Foo x "camel") == (Foo 42 "camel")</code> then <code>x</code> is <code>42</code>.</p>
<pre><code class="language-ocaml"># let solver = Solver.mk_solver ctx None;;
val solver : Solver.solver = &lt;abstr&gt;

# let e2_z3 = FuncDecl.apply ctor_f_foo [Arithmetic.Integer.mk_const_s ctx "x"; box_string "camel"];;
val e2_z3 : Expr.expr = &lt;abstr&gt;

# let solver_result = Solver.check solver [Boolean.mk_eq ctx e1_z3 e2_z3];;
val solver_result : Solver.status = Z3.Solver.SATISFIABLE

# match solver_result with Solver.SATISFIABLE -&gt; 
  (match Solver.get_model solver with 
    | Some model -&gt; Model.to_string model
    | None -&gt; "no model")
  | _ -&gt; "not sat";;
- : string = "(define-fun x () Int\n  42)"
</code></pre>
<p>Now we have all the ingredients to write <code>inj</code> functions in Z3 land and the <code>box</code> from OCaml to Z3.</p>
<pre><code class="language-ocaml"># let inj_foo (ei,es) = FuncDecl.apply ctor_f_foo [ei; es];;
val inj_foo : Expr.expr * Expr.expr -&gt; Expr.expr = &lt;fun&gt;
# let inj_bar ei = FuncDecl.apply ctor_f_bar [ei];;
val inj_bar : Expr.expr -&gt; Expr.expr = &lt;fun&gt;
# let box_t1 = function 
  | Foo (i,s) -&gt; inj_foo (box_int i, box_string s) 
  | Bar i -&gt; inj_bar (box_int i);;
val box_t1 : t1 -&gt; Expr.expr = &lt;fun&gt;

# box_t1 (Foo (101, "dog")) |&gt; Expr.to_string;;
- : string = "(Foo 101 \"dog\")"
</code></pre>
<p><code>rzer_*</code>(recognizer) and <code>asor_*</code>(accessor) are got from <code>t1_sort</code>.</p>
<pre><code class="language-ocaml"># #show t1;;
type nonrec t1 = Foo of int * string | Bar of int

# let rzer_foo, rzer_bar = 
  match Datatype.get_recognizers t1_sort with 
  | [ rzer_foo; rzer_bar ] -&gt; (rzer_foo, rzer_bar) 
  | _ -&gt; failwith "recogniziers mismatch";;
val rzer_foo : FuncDecl.func_decl = &lt;abstr&gt;
val rzer_bar : FuncDecl.func_decl = &lt;abstr&gt;

# let (asor_foo_0, asor_foo_1), asor_bar_0 = 
  match Datatype.get_accessors t1_sort with 
  | [ [ asor_foo_0; asor_foo_1 ]; [ asor_bar_0 ] ] -&gt; ((asor_foo_0, asor_foo_1), (asor_bar_0)) 
  | _ -&gt; failwith "accessors mismatch";;
val asor_foo_0 : FuncDecl.func_decl = &lt;abstr&gt;
val asor_foo_1 : FuncDecl.func_decl = &lt;abstr&gt;
val asor_bar_0 : FuncDecl.func_decl = &lt;abstr&gt;
</code></pre>
<p>Recognizers share the shape of variant cases. Accessors share the shape of variant cases and the inner payload types. It's also the same shape with the constructors.</p>
<pre><code class="language-ocaml"># let ei = FuncDecl.apply rzer_foo [e1_z3];;
val ei : Expr.expr = &lt;abstr&gt;

# Expr.to_string ei;;
- : string = "((_ is Foo) (Foo 42 \"camel\"))"
</code></pre>
<p>Here comes the subtle question. <code>FuncDecl.apply</code> builds a function application in Z3 land, but it's just an unevaluated expression.</p>
<pre><code class="language-ocaml"># let unbox_bool v = match Boolean.get_bool_value v with | L_TRUE -&gt; true | L_FALSE -&gt; false | _ -&gt; failwith "L_UNDEF";;
val unbox_bool : Expr.expr -&gt; bool = &lt;fun&gt;

# unbox_bool ei;;
Exception: Failure "L_UNDEF".
</code></pre>
<p>It's not a problem for the box direction because we can <strong>evaluate</strong> in OCaml land, box the result, and build the Z3 expression. To force the <strong>evaluation</strong> in Z3 land, we can use <code>Expr.simplify ctx</code>.</p>
<pre><code class="language-ocaml"># let ei' = Expr.simplify ei None;;
val ei' : Expr.expr = &lt;abstr&gt;

# Expr.to_string ei';;
- : string = "true"

# unbox_bool ei';;
- : bool = true
</code></pre>
<p>Now we have all the ingredients to write <code>prj</code> functions in Z3 land and the <code>unbox</code> from Z3 to OCaml.</p>
<pre><code class="language-ocaml"># let is_foo e = FuncDecl.apply rzer_foo [ e ];;
val is_foo : Expr.expr -&gt; Expr.expr = &lt;fun&gt;
# let prj_foo_0 e = FuncDecl.apply asor_foo_0 [ e ];;
val prj_foo_0 : Expr.expr -&gt; Expr.expr = &lt;fun&gt;
# let prj_foo_1 e = FuncDecl.apply asor_foo_1 [ e ];;
val prj_foo_1 : Expr.expr -&gt; Expr.expr = &lt;fun&gt;

# let is_bar e = FuncDecl.apply rzer_bar [ e ];;
val is_bar : Expr.expr -&gt; Expr.expr = &lt;fun&gt;
# let prj_bar_0 e = FuncDecl.apply asor_bar_0 [ e ];;
val prj_bar_0 : Expr.expr -&gt; Expr.expr = &lt;fun&gt;

# let unbox_t1 e = 
      match e with
      | _ when Expr.simplify (is_foo e) None |&gt; unbox_bool -&gt;
          Foo
            ( Expr.simplify (prj_foo_0 e) None |&gt; unbox_int,
              Expr.simplify (prj_foo_1 e) None |&gt; unbox_string )
      | _ when Expr.simplify (is_bar e) None |&gt; unbox_bool -&gt;
          Bar
            ( Expr.simplify (prj_bar_0 e) None |&gt; unbox_int )
      | _ -&gt; failwith "not here";;
val unbox_t1 : Expr.expr -&gt; t1 = &lt;fun&gt;

# unbox_t1 e1_z3;;
- : t1 = Foo (42, "camel")
</code></pre>
<p>All set for our expected functions!</p>
<h2 id="making-z3-datatype-by-fairy-magic"><a class="header" href="#making-z3-datatype-by-fairy-magic">Making Z3 Datatype by fairy magic</a></h2>
<p>If you don't want to write the above functions, just use <code>fairy_z3.ppx</code>. To check the generated function, change <code>[@@deriving ..]</code> to <code>[@@deriving_inline ..] [@@@end]</code>.</p>
<pre><code class="language-ocaml">type t1 = Foo of int * string | Bar of int
[@@deriving z3 ~flag ~bv_width:52]
</code></pre>
<h2 id="summary-and-to-do"><a class="header" href="#summary-and-to-do">Summary and To-do</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Read (ocaml-)z3 source code to understand its datatype API better.</li>
<li><input disabled="" type="checkbox"/>
Support more type constructors in OCaml.</li>
<li><input disabled="" type="checkbox"/>
Allow more customizing for primitives box and unbox function.</li>
<li><input disabled="" type="checkbox"/>
Make it more easier to use.</li>
<li><input disabled="" type="checkbox"/>
Add more testing.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-are-deriving-compare-sexp_of-hash-for"><a class="header" href="#what-are-deriving-compare-sexp_of-hash-for">What are [@@deriving compare, sexp_of, hash] for?</a></h1>
<p>Real World OCaml has a dedicated chapter <a href="https://dev.realworldocaml.org/maps-and-hashtables.html">Maps and Hash Tables</a>. It's an excellent tutorial to start with data containers in Jane Street's <code>core</code> (or <code>Base</code>), an alternative to the OCaml standard library <code>stdlib</code>. For both <code>core</code> and <code>stdlib</code>, elements need to provide required <em>functions</em> to be put into containers. The tutorial gives examples of elements with hand-written functions and derived functions.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=book1 -->
<pre><code class="language-ocaml">  open Core

  module Book = struct
    module T = struct
      type t = { title : string; isbn : string }

      let compare t1 t2 =
        let cmp_title = String.compare t1.title t2.title in
        if cmp_title &lt;&gt; 0 then cmp_title else String.compare t1.isbn t2.isbn

      let sexp_of_t t : Sexp.t = List [ Atom t.title; Atom t.isbn ]
    end

    include T
    include Comparator.Make (T)
  end
</code></pre>
<!-- $MDX file=../../src-ocaml/elements.ml,part=book2 -->
<pre><code class="language-ocaml">  open Core

  module Book = struct
    module T = struct
      type t = { title : string; isbn : string } [@@deriving compare, sexp_of]
    end

    include T
    include Comparator.Make (T)
  end
</code></pre>
<p>Let's focus in what's inside of <code>T</code>. In this post, we will figure out one question:</p>
<p>What are <code>[@@deriving compare, sexp_of, hash]</code> for, as the post title askes?</p>
<p>We will answer this question from the user-code side, and left the explanation from the library-code side for the future.</p>
<h2 id="deriving-functions"><a class="header" href="#deriving-functions">Deriving Functions</a></h2>
<p>These ppx deriver are <a href="https://github.com/janestreet/ppx_compare">janestreet/ppx_compare</a> for <code>equal</code> and <code>compare</code>, <a href="https://github.com/janestreet/ppx_sexp_conv">janestreet/ppx_sexp_conv</a> for <code>sexp_of</code> and <code>of_sexp</code>, and <a href="https://github.com/janestreet/ppx_hash">janestreet/ppx_hash</a> for <code>hash</code> and <code>hash_fold</code>.</p>
<p>A quick way to inspect the deriving result is to change <code>[@@deriving &lt;ppx&gt;]</code> to <code>[@@deriving_inline &lt;ppx&gt;] [@@@end]</code> so there we can read the generated code between tags.</p>
<p>The idea of all these function deriver are type-based structural traversal. Don't be disturbed by the variable names in the generated code.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=pair_inline_equal -->
<pre><code class="language-ocaml">type foo1 = P1 of int * string [@@deriving_inline equal]

let _ = fun (_ : foo1) -&gt; ()

let equal_foo1 =
  (fun a__008_ b__009_ -&gt;
     if Stdlib.( == ) a__008_ b__009_ then true
     else
       match (a__008_, b__009_) with
       | P1 (_a__010_, _a__012_), P1 (_b__011_, _b__013_) -&gt;
           Stdlib.( &amp;&amp; )
             (equal_int _a__010_ _b__011_)
             (equal_string _a__012_ _b__013_)
    : foo1 -&gt; foo1 -&gt; bool)

let _ = equal_foo1

[@@@end]
</code></pre>
<p><code>equal</code> is straightforward. Two values are equal if they are physically equal i.e. at the same memory address. Otherwises, they need to be equal piecewise-ly. <code>Core</code> doesn't shadow OCaml vanilla standard library <code>Stdlib</code>.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=pair_inline_compare -->
<pre><code class="language-ocaml">type foo2 = P2 of int * string [@@deriving_inline compare]

let _ = fun (_ : foo2) -&gt; ()

let compare_foo2 =
  (fun a__014_ b__015_ -&gt;
     if Stdlib.( == ) a__014_ b__015_ then 0
     else
       match (a__014_, b__015_) with
       | P2 (_a__016_, _a__018_), P2 (_b__017_, _b__019_) -&gt; (
           match compare_int _a__016_ _b__017_ with
           | 0 -&gt; compare_string _a__018_ _b__019_
           | n -&gt; n)
    : foo2 -&gt; foo2 -&gt; int)

let _ = compare_foo2

[@@@end]
</code></pre>
<p><code>compare</code> is similar to <code>equal</code>. <code>Stdlib.compare : 'a -&gt; 'a -&gt; int</code> the polymorphic compare is not used in <code>Core</code>, however, the convertion should be observed: <code>compare x y</code> returns 0 if x is equal to y, a negative integer if x is less than y, and a positive integer if x is greater than y.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=pair_inline_sexp -->
<pre><code class="language-ocaml">type foo3 = P3 of int * string [@@deriving_inline sexp]

let _ = fun (_ : foo3) -&gt; ()

let foo3_of_sexp =
  (let error_source__022_ = "src-ocaml/elements.ml.foo3" in
   function
   | Sexplib0.Sexp.List
       (Sexplib0.Sexp.Atom (("p3" | "P3") as _tag__025_) :: sexp_args__026_) as
     _sexp__024_ -&gt; (
       match sexp_args__026_ with
       | [ arg0__027_; arg1__028_ ] -&gt;
           let res0__029_ = int_of_sexp arg0__027_
           and res1__030_ = string_of_sexp arg1__028_ in
           P3 (res0__029_, res1__030_)
       | _ -&gt;
           Sexplib0.Sexp_conv_error.stag_incorrect_n_args error_source__022_
             _tag__025_ _sexp__024_)
   | Sexplib0.Sexp.Atom ("p3" | "P3") as sexp__023_ -&gt;
       Sexplib0.Sexp_conv_error.stag_takes_args error_source__022_ sexp__023_
   | Sexplib0.Sexp.List (Sexplib0.Sexp.List _ :: _) as sexp__021_ -&gt;
       Sexplib0.Sexp_conv_error.nested_list_invalid_sum error_source__022_
         sexp__021_
   | Sexplib0.Sexp.List [] as sexp__021_ -&gt;
       Sexplib0.Sexp_conv_error.empty_list_invalid_sum error_source__022_
         sexp__021_
   | sexp__021_ -&gt;
       Sexplib0.Sexp_conv_error.unexpected_stag error_source__022_ sexp__021_
    : Sexplib0.Sexp.t -&gt; foo3)

let _ = foo3_of_sexp

let sexp_of_foo3 =
  (fun (P3 (arg0__031_, arg1__032_)) -&gt;
     let res0__033_ = sexp_of_int arg0__031_
     and res1__034_ = sexp_of_string arg1__032_ in
     Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "P3"; res0__033_; res1__034_ ]
    : foo3 -&gt; Sexplib0.Sexp.t)

let _ = sexp_of_foo3

[@@@end]
</code></pre>
<p><code>sexp_of</code> and <code>of_sexp</code> are for serialization and deserialization. More details are at RWO Chapter <a href="https://dev.realworldocaml.org/data-serialization.html">Data Serialization with S-Expressions</a>.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=pair_inline_hash -->
<pre><code class="language-ocaml">type foo4 = P4 of int * string [@@deriving_inline hash]

let _ = fun (_ : foo4) -&gt; ()

let (hash_fold_foo4 :
      Ppx_hash_lib.Std.Hash.state -&gt; foo4 -&gt; Ppx_hash_lib.Std.Hash.state) =
  (fun hsv arg -&gt;
     match arg with
     | P4 (_a0, _a1) -&gt;
         let hsv = hsv in
         let hsv =
           let hsv = hsv in
           hash_fold_int hsv _a0
         in
         hash_fold_string hsv _a1
    : Ppx_hash_lib.Std.Hash.state -&gt; foo4 -&gt; Ppx_hash_lib.Std.Hash.state)

let _ = hash_fold_foo4

let (hash_foo4 : foo4 -&gt; Ppx_hash_lib.Std.Hash.hash_value) =
  let func arg =
    Ppx_hash_lib.Std.Hash.get_hash_value
      (let hsv = Ppx_hash_lib.Std.Hash.create () in
       hash_fold_foo4 hsv arg)
  in
  fun x -&gt; func x

let _ = hash_foo4

[@@@end]
</code></pre>
<p>Here are the most <em>complex</em> functions. <code>hash_fold</code> is a state-passing function to perform the hashing payload. <code>hash</code> wraps <code>hash_fold</code> by providing an initial hash state via <code>Hash.create ()</code> and converting the hash result to <code>int</code> via <code>Hash.get_hash_value</code>.
It implies if we need a cutsom hash function, implementing <code>hash_fold</code> to perform hashing and providing the same wrapping <code>hash</code> here.</p>
<p>Further explanation can be found at doc for <a href="https://v3.ocaml.org/p/base/latest/doc/Base/Hasher/module-type-S/index.html">Base.Hasher.S</a> and the <a href="https://github.com/janestreet/ppx_hash/blob/master/doc/design.notes">ppx_hash/design_doc</a>. In short, <code>hash_fold</code> should take care of not only the values in the structure not also the structure itself, to avoid easily hash collision.</p>
<p>It becomes tricky when a <code>Core</code>-container is used as an element and this element is intended to be used in a container requiring hash, e.g. putting this <code>Int_set_as_element</code> in a <code>Hash_set</code>.</p>
<!-- $MDX file=../../src-ocaml/elements.ml,part=int_set_as_element -->
<pre><code class="language-ocaml">module Int_set_as_element = struct
  module T = struct
    type t = Set.M(Int).t [@@deriving_inline compare, sexp_of, hash]

    let _ = fun (_ : t) -&gt; ()

    let compare =
      (fun a__035_ b__036_ -&gt; Set.compare_m__t (module Int) a__035_ b__036_
        : t -&gt; t -&gt; int)

    let _ = compare

    let sexp_of_t =
      (fun x__037_ -&gt; Set.sexp_of_m__t (module Int) x__037_
        : t -&gt; Sexplib0.Sexp.t)

    let _ = sexp_of_t

    let (hash_fold_t :
          Ppx_hash_lib.Std.Hash.state -&gt; t -&gt; Ppx_hash_lib.Std.Hash.state) =
     fun hsv arg -&gt; Set.hash_fold_m__t (module Int) hsv arg

    and (hash : t -&gt; Ppx_hash_lib.Std.Hash.hash_value) =
      let func = Set.hash_m__t (module Int) in
      fun x -&gt; func x

    let _ = hash_fold_t
    and _ = hash

    [@@@end]
  end

  include T
  include Comparator.Make (T)
end

let _ = Set.empty (module Int_set_as_element)
let _ = Hash_set.create (module Int_set_as_element)
</code></pre>
<p>Both <code>Set.hash_m__t</code> and <code>Set.hash_fold_m__t</code> requires a first-class module implementing <code>Hasher.S</code> (which requires <code>hash_fold_t</code>). In this example, the module is <code>Int</code>. <code>Int</code> is a build-in module containing <code>hash</code> and <code>hash_fold</code>. If this is <code>Your_data</code> rather than <code>Int</code>, the generated code above for <code>Set.M(Your_data).t</code> will have <code>Set.hash_m__t (module Your_data)</code> and <code>Set.hash_fold_m__t (module Your_data)</code>. Therefore, <code>Your_data</code> have to provide <code>hash</code> and <code>hash_fold</code> functions.</p>
<p>This can explain why <code>Base.Hash_set.Key</code> contains <code>hash</code> and no <code>hash_fold</code>, but <code>ppx_hash</code> still derives both <code>hash</code> and <code>hash_fold</code>.</p>
<p>p.s. I don't claim this design is good.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-polymorphic-compare"><a class="header" href="#what-is-polymorphic-compare">What is polymorphic compare?</a></h1>
<h2 id="the-compare-function"><a class="header" href="#the-compare-function">The <code>compare</code> function</a></h2>
<p>OCaml's polymorphic compare (or <code>Stdlib.compare</code>) is tempting to use but hard to reason.</p>
<p>Polymorphic <code>compare</code> in the <a href="https://v2.ocaml.org/api/Stdlib.html#1_Comparisons">manual</a> says:</p>
<blockquote>
<p><code>val (=) : 'a -&gt; 'a -&gt; bool</code></p>
<p><code>e1 = e2</code> tests for structural equality of <code>e1</code> and <code>e2</code>. Mutable structures (e.g. references and arrays) are equal if and only if their current contents are structurally equal, even if the two mutable objects are not the same physical object. Equality between functional values raises <code>Invalid_argument</code>. Equality between cyclic data structures may not terminate.</p>
</blockquote>
<p>Intuitionally, it compares two values structurally for their representations in memory.</p>
<p>This function is error-prone. A quick example to show here is to compare two values of <code>IntSet</code>. They are <em>equal</em> respecting their elements but <em>unequal</em> respecting their memory objects. <code>Objdump</code> is from <a href="https://github.com/favonia/ocaml-objdump">favonia/ocaml-objdump</a>. <code>Stdlib.Set</code> uses a balance-tree in the implementation. A tree containing two elements has multiple morphs to be balanced.</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml"># module IntSet = Set.Make(Int);;

# let a = IntSet.(add 1 (singleton 0));;
val a : IntSet.t = &lt;abstr&gt;
# let b = IntSet.(add 0 (singleton 1));;
val b : IntSet.t = &lt;abstr&gt;

# a = b;;
- : bool = false
# IntSet.equal a b;;
- : bool = true

# #require "objdump";;
# Format.printf "@[%a@]@." Objdump.pp a;;
variant0(int(0),int(0),variant0(int(0),int(1),int(0),int(1)),int(2))

- : unit = ()
# Format.printf "@[%a@]@." Objdump.pp b;;
variant0(variant0(int(0),int(0),int(0),int(1)),int(1),int(0),int(2))

- : unit = ()
</code></pre>
<p><img src="internals//img/camel-compare.png" alt="Camel Compare" /></p>
<h2 id="compare-in-the-source"><a class="header" href="#compare-in-the-source"><code>compare</code> in the source</a></h2>
<p>In the source, <code>Stdlib.compare</code> is provided as an FFI, and the actual implementation is in the C code of the runtime:</p>
<!-- $MDX skip -->
<pre><code class="language-ocaml">(* https://github.com/ocaml/ocaml/blob/trunk/stdlib/stdlib.ml#L72 *)
external compare : 'a -&gt; 'a -&gt; int = "%compare"

(* https://github.com/ocaml/ocaml/blob/trunk/runtime/compare.c#L339 *)
CAMLprim value caml_compare(value v1, value v2)
{
  intnat res = compare_val(v1, v2, 1);
  if (res &lt; 0)
    return Val_int(LESS);
  else if (res &gt; 0)
    return Val_int(GREATER);
  else
    return Val_int(EQUAL);
}
</code></pre>
<p>The other sibing functions are also wrapping <code>compare_val</code> e.g. <code>&lt;&gt;</code>(<code>notequal</code>), <code>&lt;</code>(<code>lessthan</code>), <code>&lt;=</code>(<code>lessequal</code>) and the implementation is easy to infer. The third argument <code>total</code> is only set to <code>1</code> for <code>caml_compare</code> (a.k.a <code>Stdlib.compare</code>) and <code>0</code> otherwise.</p>
<pre><code class="language-c">// https://github.com/ocaml/ocaml/blob/trunk/runtime/compare.c#L88C42-L88C42
static intnat compare_val(value v1, value v2, int total)
{
  struct compare_stack stk;
  intnat res;
  stk.stack = stk.init_stack;
  stk.limit = stk.stack + COMPARE_STACK_INIT_SIZE;
  res = do_compare_val(&amp;stk, v1, v2, total);
  compare_free_stack(&amp;stk);
  return res;
}
</code></pre>
<p><code>campare_val</code> prepares a stack and invokes a worker function <code>do_compare_val</code> to perform the comparison. <code>do_compare_val</code> performs the structural comparison on the low-level representations. By keeping only the tag cases, a simplified <code>do_compare_val</code> is:</p>
<pre><code class="language-c">static intnat do_compare_val(struct compare_stack* stk,
                             value v1, value v2, int total)
{
  struct compare_item * sp;
  tag_t t1, t2;

  sp = stk-&gt;stack;
  while (...) {
    while (...) {
      if (v1 == v2 &amp;&amp; total) goto next_item;
      if (Is_long(v1)) {
        if (v1 == v2) goto next_item;
        if (Is_long(v2))
          return Long_val(v1) - Long_val(v2);
        switch (Tag_val(v2)) {
          case Forward_tag:
            v2 = Forward_val(v2);
            continue;
          case Custom_tag: {
            int res = compare(v1, v2);
            if (Caml_state-&gt;compare_unordered &amp;&amp; !total) return UNORDERED;
            if (res != 0) return res;
            goto next_item;
          }
          default: /*fallthrough*/;
          }
        return LESS;                /* v1 long &lt; v2 block */
      }
      if (Is_long(v2)) {
          // ... symmetry of the above code
        }
        return GREATER;            /* v1 block &gt; v2 long */
      }
      t1 = Tag_val(v1);
      t2 = Tag_val(v2);
      if (t1 != t2) {
          if (t1 == Forward_tag) { v1 = Forward_val (v1); continue; }
          if (t2 == Forward_tag) { v2 = Forward_val (v2); continue; }
          if (t1 == Infix_tag) t1 = Closure_tag;
          if (t2 == Infix_tag) t2 = Closure_tag;
          if (t1 != t2)
              return (intnat)t1 - (intnat)t2;
      }
      switch(t1) {
      case Forward_tag: {
          v1 = Forward_val (v1);
          v2 = Forward_val (v2);
          continue;
      }
      case String_tag: // ... string case

      case Double_tag: // ... double case

      case Double_array_tag: // ... double array case
      
      case Abstract_tag:
      case Closure_tag:
      case Infix_tag:
      case Cont_tag: // ... invalid cases

      case Object_tag: {
        intnat oid1 = Oid_val(v1);
        intnat oid2 = Oid_val(v2);
        if (oid1 != oid2) return oid1 - oid2;
        break;
      }
      case Custom_tag: {
        int res;
        int (*compare)(value v1, value v2) = Custom_ops_val(v1)-&gt;compare;
        /* Hardening against comparisons between different types */
        if (compare != Custom_ops_val(v2)-&gt;compare) {
          return strcmp(Custom_ops_val(v1)-&gt;identifier,
                        Custom_ops_val(v2)-&gt;identifier) &lt; 0
                 ? LESS : GREATER;
        }
        if (compare == NULL) {
          compare_free_stack(stk);
          caml_invalid_argument("compare: abstract value");
        }
        Caml_state-&gt;compare_unordered = 0;
        res = compare(v1, v2);
        if (Caml_state-&gt;compare_unordered &amp;&amp; !total) return UNORDERED;
        if (res != 0) return res;
        break;
      }
      default: {
        mlsize_t sz1 = Wosize_val(v1);
        mlsize_t sz2 = Wosize_val(v2);
        /* Compare sizes first for speed */
        if (sz1 != sz2) return sz1 - sz2;
        if (sz1 == 0) break;
        /* Remember that we still have to compare fields 1 ... sz - 1. */
        if (sz1 &gt; 1) {
          if (sp &gt;= stk-&gt;limit) sp = compare_resize_stack(stk, sp);
          struct compare_item* next = sp++;
          next-&gt;v1 = v1;
          next-&gt;v2 = v2;
          next-&gt;size = Val_long(sz1);
          next-&gt;offset = Val_long(1);
        }
        /* Continue comparison with first field */
        v1 = Field(v1, 0);
        v2 = Field(v2, 0);
        continue;
      }
      }
    next_item:
      /* Pop one more item to compare, if any */
      if (sp == stk-&gt;stack) return EQUAL; /* we're done */

      struct compare_item* last = sp-1;
      v1 = Field(last-&gt;v1, Long_val(last-&gt;offset));
      v2 = Field(last-&gt;v2, Long_val(last-&gt;offset));
      last-&gt;offset += 2;/* Long_val(last-&gt;offset) += 1 */
      if (last-&gt;offset == last-&gt;size) sp--;
    }
  }
}
</code></pre>
<p>The code here is the skeleton to compare two elements tag-wise. The code omitted is details of specific tag cases. The stack is to store elements to compare, getting from compound values.</p>
<p>At this moment, I am not clear when elements are pushed into the stack. <code>Begin_roots2(root_v1, root_v2); run_pending_actions(stk, sp);</code> is doubty.</p>
<h2 id="value-and-tag"><a class="header" href="#value-and-tag"><code>value</code> and <code>tag</code></a></h2>
<p>OCaml value is stored as a <em>value</em> in memory at runtime. <code>value</code> and tag functions, e.g. <code>Is_long</code> and <code>Tag_val</code> are defined in <a href="https://github.com/ocaml/ocaml/blob/trunk/runtime/caml/mlvalues.h"><code>runtime/caml/mlvalues.h</code></a>. OCaml manual explains tags in Chapter 22 <a href="https://v2.ocaml.org/manual/intfc.html#ss:c-blocks">Interfacing C with OCaml</a>. RWO has a clear explanation in chapter 23 <a href="https://dev.realworldocaml.org/runtime-memory-layout.html">Memory Representation of Values</a>. Here is my recap:</p>
<p>Memory <em>value</em> can be an immediate integer or a pointer to other memory. An OCaml value of primitive types e.g. <code>bool</code>, <code>int</code>, <code>unit</code> encodes to an immediate integer. The rest uses a pointer to store the extra <em>blocks</em>. The last bit of a memory word is used to identify them: <code>1</code> marks immediate integers and <code>0</code> marks a pointer. OCaml enforces word-aligned memory addresses.</p>
<p>A block, which a pointer value points to, contains a header and variable-length data. The header has the size of the block and a tag identifying whether to interpret the payload data as opaque bytes or OCaml values.</p>
<p>Here is a rusty table pairing the summary from RWO and the handling case from <code>compare.c</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>OCaml type</th><th>Value/Tag</th><th>Compare case</th></tr></thead><tbody>
<tr><td>int</td><td>immediate</td><td><code>Is_long</code></td></tr>
<tr><td>enforced lazy value</td><td><code>Forward_tag</code></td><td>via <code>Forward_val</code></td></tr>
<tr><td>abstract datatype with user functions</td><td><code>Custom_tag</code></td><td>via <code>-&gt;compare_ext</code></td></tr>
<tr><td>function (closure)</td><td><code>Infix_tag</code></td><td>via <code>Closure_tag</code></td></tr>
<tr><td>string</td><td><code>String_tag</code></td><td><code>case String_tag</code></td></tr>
<tr><td>float</td><td><code>Double_tag</code></td><td><code>case Double_tag</code></td></tr>
<tr><td>float array</td><td><code>Double_array_tag</code></td><td><code>case Double_array_tag</code></td></tr>
<tr><td>abstract datatype</td><td><code>Abstract_tag</code></td><td>invalid <code>abstract value</code></td></tr>
<tr><td>function (closure)</td><td><code>Closure_tag</code></td><td>invalid <code>functional value</code></td></tr>
<tr><td>(handling effects inside callbacks)</td><td><code>Cont_tag</code></td><td>invalid <code>continuation value</code></td></tr>
<tr><td>object</td><td><code>Object_tag</code></td><td>via <code>Oid_val</code></td></tr>
</tbody></table>
</div>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>Some omitted code in <code>compare.c</code> above is for GC interrupts. It's heavily discussed in <a href="https://github.com/ocaml/ocaml/pull/12128">ocaml/#12128</a>.</p>
<p>Polymorphic compare is also dicussed in e.g. OCaml Discuss <a href="https://discuss.ocaml.org/t/removing-polymorphic-compare-from-core/2994">removing-polymorphic-compare</a> and even over <a href="https://blog.janestreet.com/the-perils-of-polymorphic-compare/">a decade ago</a>.</p>
<p>The post makes a rough but clear explanation. <del>Only use it with care.</del></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-set-and-hashtables"><a class="header" href="#map-set-and-hashtables">Map, Set and Hashtables</a></h1>
<p>What are exact functions required for distinct data containers?</p>
<p>Afterr all, what collections are in <code>Base</code> and <code>Core</code>?</p>
<div class="table-wrapper"><table><thead><tr><th>Base</th><th>Core</th><th>Stdlib</th><th>Kind</th><th>Requiring</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>Applicative</code></td><td></td><td>/</td><td>functor</td><td></td><td><code>base</code> lib</td></tr>
<tr><td><code>Array</code></td><td><code>Array</code></td><td><code>Array</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Avltree</code></td><td></td><td>/</td><td>low-level</td><td></td><td></td></tr>
<tr><td><code>Backtrace</code></td><td></td><td><code>Printexc.raw_backtrace</code></td><td>system</td><td></td><td></td></tr>
<tr><td><code>Binary_search</code></td><td></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td><code>Binary_searchable</code></td><td></td><td>/</td><td>functor</td><td></td><td></td></tr>
<tr><td><code>Blit</code></td><td><code>Blit</code></td><td>/</td><td>std</td><td></td><td>bit-block transfer</td></tr>
<tr><td><code>Bool</code></td><td><code>Bool</code></td><td><code>Bool</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Buffer</code></td><td></td><td><code>Buffer</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Bytes</code></td><td><code>Bytes</code></td><td><code>Bytes</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Char</code></td><td><code>Char</code></td><td><code>Char</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Comparable</code></td><td></td><td>/</td><td>functor</td><td></td><td></td></tr>
<tr><td><code>Comparator</code></td><td></td><td>/</td><td>functor</td><td></td><td></td></tr>
<tr><td><code>Comparisons</code></td><td></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td><code>Container</code></td><td><code>Container_intf</code></td><td>/</td><td>functor</td><td></td><td></td></tr>
<tr><td><code>Either</code></td><td><code>Either</code></td><td><code>Either</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Equal</code></td><td></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td><code>Error</code></td><td><code>Error</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Exn</code></td><td></td><td><code>exn</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Export</code></td><td></td><td>/</td><td>wrap</td><td></td><td>undoc</td></tr>
<tr><td><code>Field</code></td><td></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Float</code></td><td><code>Float</code></td><td><code>Float</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Floatable</code></td><td></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td><code>Fn</code></td><td></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Formatter</code></td><td></td><td><code>Formatter</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Hash</code></td><td></td><td>/</td><td>std</td><td></td><td>hash primitives</td></tr>
<tr><td><code>Hash_set</code></td><td><code>Hash_set</code></td><td>/</td><td>container</td><td><code>compare, sexp_of, hash</code></td><td></td></tr>
<tr><td><code>Hashable</code></td><td><code>Hashable</code></td><td>/</td><td>interface</td><td></td><td>module trait</td></tr>
<tr><td><code>Hasher</code></td><td></td><td>/</td><td>interface</td><td></td><td>just <code>t</code> and <code>hash_fold_t</code></td></tr>
<tr><td><code>Hashtbl</code></td><td></td><td><code>Hashtbl</code></td><td>container</td><td><code>compare, sexp_of, hash</code></td><td></td></tr>
<tr><td><code>Identifiable</code></td><td><code>Identifiable</code></td><td>/</td><td>functor</td><td></td><td></td></tr>
<tr><td><code>Indexed_container</code></td><td><code>Indexed_container</code></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td><code>Info</code></td><td><code>Info</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Int</code></td><td><code>Int</code></td><td><code>Int</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Int32</code></td><td><code>Int32</code></td><td><code>Int32</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Int63</code></td><td><code>Int63</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Int64</code></td><td><code>Int64</code></td><td><code>Int64</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Int_conversions</code></td><td></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Intable</code></td><td></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td><code>Int_math</code></td><td></td><td>/</td><td>functor</td><td></td><td></td></tr>
<tr><td><code>Invariant</code></td><td></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td><code>Lazy</code></td><td><code>Lazy</code></td><td><code>Lazy</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Linked_queue</code></td><td><code>Linked_queue</code></td><td><code>Queue </code></td><td>container</td><td></td><td></td></tr>
<tr><td><code>List</code></td><td></td><td><code>List</code></td><td>container</td><td></td><td></td></tr>
<tr><td><code>Map</code></td><td><code>Map</code></td><td><code>Map</code></td><td>container</td><td><code>compare, sexp_of</code></td><td>balanced binary tree over a totally-ordered domain</td></tr>
<tr><td><code>Maybe_bound</code></td><td><code>Maybe_bound</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Monad</code></td><td></td><td>/</td><td>functor</td><td></td><td></td></tr>
<tr><td><code>Nativeint</code></td><td><code>Nativeint</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Nothing</code></td><td><code>Nothing</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Option</code></td><td><code>Option</code></td><td><code>Option</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Option_array</code></td><td><code>Option_array</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Or_error</code></td><td><code>Or_error</code></td><td>/</td><td>std</td><td></td><td>a specialization of the <code>Result</code> type</td></tr>
<tr><td><code>Ordered_collection_common</code></td><td><code>Ordered_collection_common</code></td><td>/</td><td>trait</td><td></td><td></td></tr>
<tr><td><code>Ordering</code></td><td><code>Ordering</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Poly</code></td><td></td><td><code>Stdlib</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Pretty_printer</code></td><td></td><td>/</td><td>std</td><td></td><td>for use in toplevels</td></tr>
<tr><td><code>Printf</code></td><td><code>Printf</code></td><td><code>Printf</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Queue</code></td><td><code>Queue</code></td><td><code>Queue</code></td><td>std</td><td></td><td>A queue implemented with an array</td></tr>
<tr><td><code>Random</code></td><td></td><td><code>Random</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Ref</code></td><td><code>Ref</code></td><td><code>'a ref</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Result</code></td><td><code>Result</code></td><td><code>Result</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Sequence</code></td><td><code>Sequence</code></td><td><code>Seq</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Set</code></td><td><code>Set</code></td><td><code>Set</code></td><td>std</td><td></td><td>Sets based on <code>Comparator.S</code></td></tr>
<tr><td><code>Sexp</code></td><td><code>Sexp</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Sexpable</code></td><td><code>Sexpable</code></td><td>/</td><td>functor</td><td></td><td></td></tr>
<tr><td><code>Sign</code></td><td><code>Sign</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Sign_or_nan</code></td><td><code>Sign_or_nan</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Source_code_position</code></td><td><code>Source_code_position</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Stack</code></td><td><code>Stack</code></td><td><code>Stack</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Staged</code></td><td></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td><code>String</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Stringable</code></td><td><code>Stringable</code></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td><code>Sys</code></td><td><code>Sys</code></td><td><code>Sys</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>T</code></td><td></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td><code>Type_equal</code></td><td><code>Type_equal</code></td><td>/</td><td>std</td><td></td><td>to represent type equalities that the type checker otherwise would not know</td></tr>
<tr><td><code>Uniform_array</code></td><td><code>Uniform_array</code></td><td>/</td><td>std</td><td></td><td>guaranteed that the representation array is not tagged with <code>Double_array_tag</code></td></tr>
<tr><td><code>Unit</code></td><td><code>Unit</code></td><td><code>unit</code></td><td>std</td><td></td><td></td></tr>
<tr><td><code>Uchar</code></td><td></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Variant</code></td><td></td><td>/</td><td>std</td><td></td><td>used in <code>[@@deriving variants]</code></td></tr>
<tr><td><code>With_return</code></td><td></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td><code>Word_size</code></td><td></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td><code>Base_internalhash_types</code></td><td></td><td>/</td><td>std</td><td></td><td><code>base.base_internalhash_types</code> lib</td></tr>
<tr><td><code>Md5_lib</code></td><td></td><td>/</td><td>std</td><td></td><td><code>base.md5</code> lib</td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td><code>Arg</code></td><td><code>Stdlib.Arg</code></td><td>std</td><td></td><td><code>core</code> lib; <code>Command</code> module is generally recommended over this</td></tr>
<tr><td></td><td><code>Bag</code></td><td>/</td><td>container</td><td></td><td></td></tr>
<tr><td></td><td><code>Bigbuffer</code></td><td>/</td><td>std</td><td></td><td>Extensible string buffers based on <code>Bigstrings</code></td></tr>
<tr><td></td><td><code>Bigstring</code></td><td>/</td><td>std</td><td></td><td><code>String</code> type based on <code>Bigarray</code></td></tr>
<tr><td></td><td><code>Bigsubstring</code></td><td>/</td><td>std</td><td></td><td><code>Substring</code> type based on <code>Bigarray</code></td></tr>
<tr><td></td><td><code>Bin_prot</code></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td></td><td><code>Binable</code></td><td>/</td><td>functor</td><td></td><td></td></tr>
<tr><td></td><td><code>Blang</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Bounded_index </code></td><td>/</td><td>std</td><td></td><td>unique index types with explicit bounds and human-readable labels</td></tr>
<tr><td></td><td><code>Byte_units</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Command</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Container</code></td><td>/</td><td>interface</td><td></td><td></td></tr>
<tr><td></td><td><code>Core_stable</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Date</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Day_of_week</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Debug</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Deque</code></td><td>/</td><td>container</td><td></td><td></td></tr>
<tr><td></td><td><code>Doubly_linked</code></td><td>/</td><td>container</td><td></td><td></td></tr>
<tr><td></td><td><code>Fdeque</code></td><td>/</td><td>container</td><td></td><td></td></tr>
<tr><td></td><td><code>Filename</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Float_with_finite_only_serialization</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Fqueue</code></td><td>/</td><td>container</td><td></td><td></td></tr>
<tr><td></td><td><code>Gc</code></td><td><code>Gc</code></td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Hash_queue</code></td><td>/</td><td>container</td><td></td><td></td></tr>
<tr><td></td><td><code>Heap_block</code></td><td>/</td><td>std</td><td></td><td><code>Core.heap_block</code> lib</td></tr>
<tr><td></td><td><code>Hexdump</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Host_and_port</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Immediate_option</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>In_channel</code></td><td>/</td><td>std</td><td></td><td><code>Stdio.In_channel</code></td></tr>
<tr><td></td><td><code>Interfaces</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Md5</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Month</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Mutex</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Only_in_test</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Optional_syntax</code></td><td>/</td><td>std</td><td></td><td>provided by <code>ppx_optional</code></td></tr>
<tr><td></td><td><code>Out_channel</code></td><td>/</td><td>std</td><td></td><td><code>Stdio.Out_channel</code></td></tr>
<tr><td></td><td><code>Percent</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Perms</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Pid</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Printexc</code></td><td><code>Printexc</code></td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Quickcheck</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Quickcheckable</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Robustly_comparable</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Set_once</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Sexp_maybe</code></td><td>/</td><td>std</td><td></td><td><code>Sexp.Sexp_maybe</code></td></tr>
<tr><td></td><td><code>Signal</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Splittable_random</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Stable_comparable</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Stable_unit_test</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Substring</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Thread</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Time_float</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Time_ns</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Tuple</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>union_find</code></td><td>/</td><td>container</td><td></td><td></td></tr>
<tr><td></td><td><code>Unit_of_time</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Univ_map</code></td><td>/</td><td>container</td><td></td><td></td></tr>
<tr><td></td><td><code>Validate</code></td><td>/</td><td>std</td><td></td><td></td></tr>
<tr><td></td><td><code>Weak</code></td><td>/</td><td>std</td><td></td><td></td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>

        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="asset/mermaid.min.js"></script>
        <script src="asset/mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
